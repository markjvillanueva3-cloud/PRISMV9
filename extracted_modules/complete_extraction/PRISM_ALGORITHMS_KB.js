const PRISM_ALGORITHMS_KB = {
    sorting: {
        quicksort: { name: "quicksort", description: "minutes Answer all questions. All questions carry equal marks. Question 1. Show the steps that are involved in sorting the string SORTME using the quicksort algorithm given below. #include <iostream.h> void quicksort(char *a, int l, int r); main() { char str[8] = \"9SORTME\"; // ", source: "1.124j-fall-2000" },
    },
    searching: {
        dfs: { name: "dfs", description: "10 paths/pixel Note: More noise. This is not a coincidence; the integrand has higher variance (the BRDFs are "spikier"). Henrik Wann Jensen Courtesy of Henrik Wann Jensen. Used with permission. 27 Path Tracing Results: Glossy Scene • 100 paths/pixel Henrik Wann Jensen Courtesy of", source: "6.837" },
        a_: { name: "a*", description: "tion of a triangle with vertices {a, b, c} in terms of {α, β, γ}, including possible equality and inequality constraints. P(alpha,beta,gamma) = alpha*a + beta*b + gamma*c, (+1) with alpha+beta+gamma = 1 and alpha,beta,gamma >= 0. (+1) OR P(beta,gamma) = a + beta*(b-a) + gamma*(c-", source: "6.837" },
        binary_search: { name: "binary search", description: "apter 11: I/O ● Chapter 12: Templates ● chapter 14: File processing From algorithms in C++ ● Chapter 9: Quicksort ● Chapter 14: Binary search Problem 1:[40%] In this problem you need to develop a program that can handle user-provided data. You need to write the main() function an", source: "1.124j-fall-2000" },
    },
    graph: {
        prim: { name: "prim", description: "22 Monte Carlo Path Tracing • Trace only one secondary ray per recursion – Otherwise number of rays explodes! • But send many primary rays per pixel (antialiasing) 23 Monte Carlo Path Tracing • Trace only one secondary ray per recursion – Otherwise number of rays explodes! • But ", source: "6.837" },
    },
    optimization: {
        pso: { name: "pso", description: "ity and other nasty details 57 Integration • You know trapezoid, Simpson's rule, etc. 58 Monte Carlo Integration • Monte Carlo integration: use random samples and compute average – We don't keep track of spacing between samples – But we kind of hope it will be 1/N on average 59 M", source: "6.837" },
        aco: { name: "aco", description: "87 How to tackle these problems? • Deal with non-linearity: Iterative solution (steepest descent) • Compute Jacobian matrix of world position w.r.t. angles • Jacobian: "If the parameters p change by tiny amounts, what is the resulting change in the world position vWS?" • Then inv", source: "6.837" },
        newton_raphson: { name: "newton-raphson", description: "35 Newton's Method (1D) • Iterative method for solving non-linear equations • Start from initial guess x0, then iterate • Also called Newton-Raphson iteration 36 Newton's Method (1D) • Iterative method for solving non-linear equations • Start from initial guess x0, then iterate o", source: "6.837" },
        conjugate_gradient: { name: "conjugate gradient", description: "ds on the adjacent masses' positions • Makes the system cheaper to solve – Don't invert the Jacobian! – Use iterative matrix solvers like conjugate gradient, perhaps with preconditioning, etc. © David Baraff and Andrew Witkin. All rights reserved. This content is excluded from ou", source: "6.837" },
        greedy: { name: "greedy", description: "47 Compression algorithm • Approximation: Piecewise linear • Set an error bound • Decide which vertices to keep • Greedy from zero do far © ACM. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-", source: "6.837" },
        gradient_descent: { name: "gradient descent", description: "he interior and the method is not going to operate. Well, that crudest method would be follow the gradient, but we know from several situations that gradient descent can be less than optimal. So this is more subtle. Well, Newton\'s method actually -- I\'ll explain. So this is act", source: "18.086" },
        simplex: { name: "simplex", description: "d the winning corner. It\'s an interesting competition between two quite different approaches: the famous approach -- so let me write these two. The simplex methods is the best established, best known, approach for solving these problems. What\'s the idea of the simplex method? T", source: "18.086" },
    },
    numerical: {
        finite_element: { name: "finite element", description: "solve it approximately • Monte Carlo techniques use random samples for evaluating the integrals – We'll look at some simple method in a bit... • Finite element methods discretize the solution using basis functions (again!) – Radiosity, wavelets, precomputed radiance transfer, etc", source: "6.837" },
        monte_carlo: { name: "monte carlo", description: "Global Illumination and Monte Carlo MIT EECS 6.837 Computer Graphics Wojciech Matusik with many slides from Fredo Durand and Jaakko Lehtinen © ACM. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/f", source: "6.837" },
        jacobi: { name: "jacobi", description: "87 How to tackle these problems? • Deal with non-linearity: Iterative solution (steepest descent) • Compute Jacobian matrix of world position w.r.t. angles • Jacobian: "If the parameters p change by tiny amounts, what is the resulting change in the world position vWS?" • Then inv", source: "6.837" },
        runge_kutta: { name: "runge-kutta", description: "chain. This will require you to implement the diﬀerent kinds of forces (gravity, viscous drag, and springs). We have provided you with a fourth order Runge-Kutta (RK4) integrator, since the integrators you implemented are unstable. 4.1 Forces The core component of particle system", source: "6.837" },
        euler_method: { name: "euler method", description: "ill suﬀer miserably when implementing the trapezoidal rule. 3.1 Refresher on Euler and Trapezoidal Rule The simplest integrator is the explicit Euler method. For an Euler step, given state X, we examine f (X, t) at X, then step to the new state value. This requires to pick a step", source: "6.837" },
        finite_difference: { name: "finite difference", description: "reen-space change dt relates to a texture-space change du,dv. => derivatives, ( du/dt, dv/dt ). e.g. computed by hardware during rasterization often: finite difference (pixels are handled by quads) du, dv dt 54 MIP Indices Actually, you have a choice of ways to translate this der", source: "6.837" },
        fft: { name: "fft", description: "kely that the tradeoffs will come from determining the proper amount of time to spend at each grid. A possible way to do this would be to look at the FFT of the residual, try to predict the spectral content of the error, and adaptively decide which grid to move to based on that r", source: "18.086" },
        singular_value: { name: "singular value", description: "ea to form v transpose v. That is symmetric. It does have positive Eigen values. And those Eigen values, the Eigen values of v transpose v, are the singular values, or rather the singular values squared of v. So I guess I\'m saying, you can\'t trust the Eigen values of v. It\'s t", source: "18.086" },
        gauss_seidel: { name: "gauss-seidel", description: "rested? Why is everybody interested in these vectors? Because actually, that\'s what an iteration like Jacobi produces. If I use Jacobi\'s method, or Gauss-Seidel. Any of those. After one step, 3 I\'ve got b. After two steps, there\'s a multiplication by a in there, right? And so", source: "18.086" },
        cholesky: { name: "cholesky", description: "o). All dead. Write one sentence on what they are known for. Arnoldi Gram Jacobi Schur Cholesky Hadamard Jordan Schwartz Fourier Hankel Kronecker Seidel Frobenius Hessenberg Krylov Toeplitz Gauss Hestenes-Stiefel Lanczos Vandermonde Gershgorin Hilbert Markov Wilkinson Givens Hous", source: "18.086" },
        lu_decomposition: { name: "lu decomposition", description: "ing the original and the reordered K2D matrices. As can be seen from this figure, reordering the matrix produces fewer numbers of nonzeros during the LU decomposition. The Matlab code used to generate Figures 3.1-3.5 was obtained at [3]. Figure 3.2: Graph of the 9 × 9 K2D matrix ", source: "18.086" },
        fast_fourier: { name: "fast fourier", description: "will propose three methods: 1. Elimination in a good order (not using the special structure of K2D) 2. Fast Poisson Solver (applying the FFT = Fast Fourier Transform) 3. Odd-Even Reduction (since K2D is block tridiagonal). The novelty is in the Fast Poisson Solver, which uses the", source: "18.086" },
    },
    geometric: {
        triangulation: { name: "triangulation", description: "ake sense. If your surfaces don't look right, use the wireframe mode to check whether the normals are pointing outwards and if your triangulation is correct. • Exploit code modularity. B-spline control points can be converted to Bezier control points via a matrix multiplication, ", source: "6.837" },
        convex_hull: { name: "convex hull", description: "A Bézier curve is bounded by the convex hull of its control points. 27 Questions? 28 Why Does the Formula Work? • Explanation 1: – Magic! • Explanation 2: – These are smart weights that describe the influence of each control point • Explanation 3: – It is a linear combination of ", source: "6.837" },
    },
};