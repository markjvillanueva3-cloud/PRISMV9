"""
PRISM Git Integration v1.0
==========================
Auto-commit and version control for PRISM development.
Handles commits, status checks, and backup snapshots.

Usage:
    py -3 C:\PRISM\scripts\automation\git_manager.py status
    py -3 C:\PRISM\scripts\automation\git_manager.py commit "Message"
    py -3 C:\PRISM\scripts\automation\git_manager.py snapshot
    py -3 C:\PRISM\scripts\automation\git_manager.py init

Requirements:
    - Git installed and in PATH
"""

import subprocess
import json
import sys
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple

# Paths
PRISM_ROOT = Path(r"C:\PRISM")
STATE_FILE = PRISM_ROOT / "state" / "CURRENT_STATE.json"

# Files/folders to always ignore
IGNORE_PATTERNS = [
    "__pycache__",
    "*.pyc",
    ".git",
    "node_modules",
    "*.duckdb",
    "*.duckdb.wal",
    "_temp_*",
    "*.log"
]

# Auto-commit triggers
AUTO_COMMIT_FOLDERS = [
    "state",
    "skills",
    "extracted",
    "data/databases",
    "scripts"
]


def run_git(args: List[str], cwd: Path = None) -> Tuple[bool, str, str]:
    """Run a git command and return (success, stdout, stderr)."""
    if cwd is None:
        cwd = PRISM_ROOT
    
    try:
        result = subprocess.run(
            ["git"] + args,
            cwd=str(cwd),
            capture_output=True,
            text=True,
            timeout=60
        )
        return result.returncode == 0, result.stdout.strip(), result.stderr.strip()
    except FileNotFoundError:
        return False, "", "Git not found. Please install Git."
    except subprocess.TimeoutExpired:
        return False, "", "Git command timed out"
    except Exception as e:
        return False, "", str(e)


def is_git_repo() -> bool:
    """Check if PRISM_ROOT is a git repository."""
    git_dir = PRISM_ROOT / ".git"
    return git_dir.exists()


def init_repo() -> bool:
    """Initialize git repository if not exists."""
    if is_git_repo():
        print("âœ“ Git repository already exists")
        return True
    
    print("Initializing git repository...")
    
    # Create .gitignore
    gitignore_content = "\n".join([
        "# PRISM Git Ignore",
        "# Auto-generated by git_manager.py",
        "",
        "# Python",
        "__pycache__/",
        "*.pyc",
        "*.pyo",
        ".venv/",
        "venv/",
        "",
        "# Databases (large files)",
        "*.duckdb",
        "*.duckdb.wal",
        "",
        "# Temporary",
        "_temp_*",
        "*.tmp",
        "*.log",
        "",
        "# Build artifacts",
        "node_modules/",
        "dist/",
        "build/",
        "",
        "# IDE",
        ".vscode/",
        ".idea/",
        "*.swp",
        "",
        "# Large files (sync via Drive instead)",
        "MANUFACTURER_CATALOGS/",
        "*.pdf",
        "*.zip"
    ])
    
    gitignore_path = PRISM_ROOT / ".gitignore"
    with open(gitignore_path, "w") as f:
        f.write(gitignore_content)
    
    # Initialize
    success, stdout, stderr = run_git(["init"])
    if not success:
        print(f"âŒ Failed to initialize: {stderr}")
        return False
    
    print("âœ“ Git repository initialized")
    
    # Initial commit
    success, _, _ = run_git(["add", ".gitignore"])
    success, _, stderr = run_git(["commit", "-m", "Initial PRISM repository setup"])
    
    if success:
        print("âœ“ Initial commit created")
    
    return True


def get_status() -> Dict[str, List[str]]:
    """Get git status summary."""
    status = {
        "staged": [],
        "modified": [],
        "untracked": [],
        "branch": "unknown"
    }
    
    # Get branch
    success, stdout, _ = run_git(["branch", "--show-current"])
    if success:
        status["branch"] = stdout or "main"
    
    # Get status
    success, stdout, _ = run_git(["status", "--porcelain"])
    if success:
        for line in stdout.split("\n"):
            if not line.strip():
                continue
            
            status_code = line[:2]
            filename = line[3:]
            
            if status_code[0] in ("A", "M", "D", "R"):
                status["staged"].append(filename)
            if status_code[1] == "M":
                status["modified"].append(filename)
            if status_code == "??":
                status["untracked"].append(filename)
    
    return status


def show_status():
    """Display current git status."""
    if not is_git_repo():
        print("âŒ Not a git repository. Run: git_manager.py init")
        return
    
    status = get_status()
    
    print("=" * 60)
    print(f"PRISM Git Status | Branch: {status['branch']}")
    print("=" * 60)
    
    if status["staged"]:
        print(f"\nâœ“ Staged ({len(status['staged'])})")
        for f in status["staged"][:10]:
            print(f"    {f}")
        if len(status["staged"]) > 10:
            print(f"    ... and {len(status['staged']) - 10} more")
    
    if status["modified"]:
        print(f"\nâ— Modified ({len(status['modified'])})")
        for f in status["modified"][:10]:
            print(f"    {f}")
        if len(status["modified"]) > 10:
            print(f"    ... and {len(status['modified']) - 10} more")
    
    if status["untracked"]:
        print(f"\n? Untracked ({len(status['untracked'])})")
        for f in status["untracked"][:10]:
            print(f"    {f}")
        if len(status["untracked"]) > 10:
            print(f"    ... and {len(status['untracked']) - 10} more")
    
    if not any([status["staged"], status["modified"], status["untracked"]]):
        print("\nâœ“ Working tree clean")
    
    print()


def commit(message: str, add_all: bool = True) -> bool:
    """Create a commit with the given message."""
    if not is_git_repo():
        print("âŒ Not a git repository")
        return False
    
    # Add files
    if add_all:
        success, _, stderr = run_git(["add", "-A"])
        if not success:
            print(f"âŒ Failed to stage files: {stderr}")
            return False
    
    # Check if there's anything to commit
    status = get_status()
    if not status["staged"] and not status["modified"]:
        print("Nothing to commit")
        return True
    
    # Get session info for commit message
    session_info = ""
    if STATE_FILE.exists():
        with open(STATE_FILE) as f:
            state = json.load(f)
        session = state.get("currentSession", {})
        session_id = session.get("id", "")
        if session_id:
            session_info = f"[{session_id}] "
    
    # Create commit
    full_message = f"{session_info}{message}"
    success, stdout, stderr = run_git(["commit", "-m", full_message])
    
    if success:
        print(f"âœ“ Committed: {full_message}")
        return True
    else:
        if "nothing to commit" in stderr:
            print("Nothing to commit")
            return True
        print(f"âŒ Commit failed: {stderr}")
        return False


def create_snapshot(name: str = None) -> bool:
    """Create a tagged snapshot (useful for milestones)."""
    if not is_git_repo():
        print("âŒ Not a git repository")
        return False
    
    # Generate snapshot name
    if name is None:
        name = f"snapshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    # First commit any changes
    commit(f"Snapshot: {name}")
    
    # Create tag
    success, _, stderr = run_git(["tag", "-a", name, "-m", f"Snapshot: {name}"])
    
    if success:
        print(f"âœ“ Created snapshot tag: {name}")
        return True
    else:
        print(f"âŒ Failed to create tag: {stderr}")
        return False


def auto_commit() -> bool:
    """Auto-commit if there are changes in monitored folders."""
    if not is_git_repo():
        return False
    
    status = get_status()
    
    # Check if changes are in auto-commit folders
    changes = status["modified"] + status["untracked"]
    relevant_changes = []
    
    for change in changes:
        for folder in AUTO_COMMIT_FOLDERS:
            if change.startswith(folder) or f"/{folder}" in change:
                relevant_changes.append(change)
                break
    
    if not relevant_changes:
        return False
    
    # Create auto-commit
    message = f"Auto-commit: {len(relevant_changes)} file(s) changed"
    return commit(message)


def get_log(count: int = 10) -> List[Dict[str, str]]:
    """Get recent commit log."""
    success, stdout, _ = run_git([
        "log",
        f"-{count}",
        "--pretty=format:%H|%s|%ai|%an"
    ])
    
    if not success:
        return []
    
    commits = []
    for line in stdout.split("\n"):
        if not line:
            continue
        parts = line.split("|")
        if len(parts) >= 4:
            commits.append({
                "hash": parts[0][:8],
                "message": parts[1],
                "date": parts[2],
                "author": parts[3]
            })
    
    return commits


def show_log(count: int = 10):
    """Display recent commit history."""
    if not is_git_repo():
        print("âŒ Not a git repository")
        return
    
    commits = get_log(count)
    
    print("=" * 60)
    print(f"PRISM Git Log (last {count} commits)")
    print("=" * 60)
    
    for commit in commits:
        print(f"\n{commit['hash']} | {commit['date'][:10]}")
        print(f"  {commit['message']}")
    
    if not commits:
        print("\nNo commits yet")
    
    print()


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="PRISM Git Integration")
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Init
    subparsers.add_parser("init", help="Initialize git repository")
    
    # Status
    subparsers.add_parser("status", help="Show git status")
    
    # Commit
    commit_parser = subparsers.add_parser("commit", help="Create a commit")
    commit_parser.add_argument("message", help="Commit message")
    commit_parser.add_argument("--no-add", action="store_true", help="Don't auto-add files")
    
    # Snapshot
    snapshot_parser = subparsers.add_parser("snapshot", help="Create a tagged snapshot")
    snapshot_parser.add_argument("--name", "-n", help="Snapshot name")
    
    # Auto-commit
    subparsers.add_parser("auto", help="Auto-commit if changes detected")
    
    # Log
    log_parser = subparsers.add_parser("log", help="Show commit history")
    log_parser.add_argument("--count", "-n", type=int, default=10, help="Number of commits")
    
    args = parser.parse_args()
    
    if args.command == "init":
        init_repo()
    elif args.command == "status":
        show_status()
    elif args.command == "commit":
        commit(args.message, add_all=not args.no_add)
    elif args.command == "snapshot":
        create_snapshot(args.name)
    elif args.command == "auto":
        if auto_commit():
            print("âœ“ Auto-commit completed")
        else:
            print("No changes to auto-commit")
    elif args.command == "log":
        show_log(args.count)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()

