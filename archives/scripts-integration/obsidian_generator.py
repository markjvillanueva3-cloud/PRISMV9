"""
PRISM Obsidian Note Generator v1.0
==================================
Generates interlinked Obsidian notes from PRISM data.
Creates knowledge graph for skills, materials, sessions, and more.

Usage:
    py -3 C:\PRISM\scripts\integration\obsidian_generator.py
    py -3 C:\PRISM\scripts\integration\obsidian_generator.py --skills
    py -3 C:\PRISM\scripts\integration\obsidian_generator.py --materials
    py -3 C:\PRISM\scripts\integration\obsidian_generator.py --sessions

Requirements:
    None (uses standard library only)
"""

import json
import re
import sys
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional

# Paths
PRISM_ROOT = Path(r"C:\PRISM")
KNOWLEDGE_PATH = PRISM_ROOT / "knowledge"
SKILLS_PATH = PRISM_ROOT / "skills"
DATA_PATH = PRISM_ROOT / "data"
STATE_PATH = PRISM_ROOT / "state"

# Note templates
SKILL_TEMPLATE = """# {name}

## Overview
- **Level**: {level}
- **Category**: {category}
- **Triggers**: {triggers}
- **File**: `{file_path}`

## Description
{description}

## Related Skills
{related_links}

## Tags
{tags}

---
*Auto-generated by PRISM Obsidian Generator*
*Last updated: {timestamp}*
"""

MATERIAL_TEMPLATE = """# {name}

## Properties
| Property | Value |
|----------|-------|
| **ID** | {material_id} |
| **Category** | {category} |
| **ISO Group** | {iso_group} |
| **Density** | {density} kg/mÂ³ |

## Cutting Parameters
| Parameter | Value |
|-----------|-------|
| **kc1.1** | {kc1_1} N/mmÂ² |
| **mc** | {mc} |
| **n (Taylor)** | {n_taylor} |

## Related Materials
{related_links}

## Tags
{tags}

---
*Auto-generated by PRISM Obsidian Generator*
"""

SESSION_TEMPLATE = """# Session: {session_id}

## Summary
- **Date**: {date}
- **Status**: {status}
- **Phase**: {phase}

## Quick Resume
{quick_resume}

## Tasks Completed
{tasks}

## Links
- [[Sessions/_Index|All Sessions]]

## Tags
#session #{status_tag}

---
*Auto-generated from CURRENT_STATE.json*
"""


def sanitize_filename(name: str) -> str:
    """Make string safe for filename."""
    # Remove or replace invalid characters
    invalid = r'<>:"/\|?*'
    for char in invalid:
        name = name.replace(char, '_')
    # Limit length
    return name[:100].strip()


def create_wikilink(name: str) -> str:
    """Create Obsidian wikilink."""
    return f"[[{sanitize_filename(name)}]]"


def generate_skill_notes() -> int:
    """Generate Obsidian notes for all skills."""
    skills_kb_path = KNOWLEDGE_PATH / "Skills"
    skills_kb_path.mkdir(parents=True, exist_ok=True)
    
    # Try to load skill tree registry
    tree_registry_path = DATA_PATH / "coordination" / "SKILL_TREE_REGISTRY.json"
    skills_data = {}
    
    if tree_registry_path.exists():
        with open(tree_registry_path, "r", encoding="utf-8") as f:
            registry = json.load(f)
            # Extract skill information from tree structure
            if "tree" in registry:
                for level_name, level_data in registry["tree"].items():
                    if not level_name.startswith("L"):
                        continue
                    
                    if "skills" in level_data:
                        for skill in level_data["skills"]:
                            skills_data[skill] = {
                                "level": level_name,
                                "category": level_data.get("description", ""),
                                "triggers": level_data.get("triggers", [])
                            }
                    
                    if "sub_branches" in level_data:
                        for branch_name, branch_data in level_data["sub_branches"].items():
                            for skill in branch_data.get("skills", []):
                                skills_data[skill] = {
                                    "level": level_name,
                                    "category": branch_name,
                                    "triggers": branch_data.get("triggers", [])
                                }
    
    # Scan skill files
    skill_folders = [
        SKILLS_PATH,
        Path("/mnt/skills/user") if Path("/mnt/skills/user").exists() else None
    ]
    
    count = 0
    all_skills = []
    
    for folder in skill_folders:
        if folder is None or not folder.exists():
            continue
        
        for skill_file in folder.glob("**/*.md"):
            skill_name = skill_file.stem
            all_skills.append(skill_name)
            
            # Get metadata from registry or infer from path
            metadata = skills_data.get(skill_name, {})
            level = metadata.get("level", "Unknown")
            category = metadata.get("category", skill_file.parent.name)
            triggers = metadata.get("triggers", [])
            
            # Read first few lines for description
            try:
                with open(skill_file, "r", encoding="utf-8") as f:
                    content = f.read(500)
                    # Extract first paragraph or heading
                    lines = content.split("\n")
                    description = ""
                    for line in lines[1:10]:  # Skip title
                        if line.strip() and not line.startswith("#"):
                            description = line.strip()
                            break
            except:
                description = "No description available"
            
            # Find related skills (same category or similar name)
            related = []
            for other in all_skills:
                if other != skill_name:
                    skill_parts = skill_name.split("-")
                    if category.lower() in other.lower() or (len(skill_parts) > 1 and skill_parts[1] in other):
                        related.append(create_wikilink(other))
            
            # Generate note
            note_content = SKILL_TEMPLATE.format(
                name=skill_name,
                level=level,
                category=category,
                triggers=", ".join(triggers) if triggers else "None specified",
                file_path=str(skill_file),
                description=description,
                related_links="\n".join(f"- {link}" for link in related[:5]) or "- None found",
                tags=" ".join(f"#skill #{level.lower()} #{sanitize_filename(category).lower().replace(' ', '-')}" .split()),
                timestamp=datetime.now().strftime("%Y-%m-%d %H:%M")
            )
            
            # Write note
            note_path = skills_kb_path / f"{sanitize_filename(skill_name)}.md"
            with open(note_path, "w", encoding="utf-8") as f:
                f.write(note_content)
            
            count += 1
    
    # Create index note
    index_content = f"""# Skills Index

## Overview
Total skills: {count}

## By Level
"""
    
    # Group by level
    level_groups = {}
    for skill_name, meta in skills_data.items():
        level = meta.get("level", "Unknown")
        if level not in level_groups:
            level_groups[level] = []
        level_groups[level].append(skill_name)
    
    for level in sorted(level_groups.keys()):
        index_content += f"\n### {level}\n"
        for skill in sorted(level_groups[level]):
            index_content += f"- {create_wikilink(skill)}\n"
    
    index_content += f"\n---\n*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*"
    
    index_path = skills_kb_path / "_Index.md"
    with open(index_path, "w", encoding="utf-8") as f:
        f.write(index_content)
    
    return count


def generate_material_notes() -> int:
    """Generate Obsidian notes for materials."""
    materials_kb_path = KNOWLEDGE_PATH / "Materials"
    materials_kb_path.mkdir(parents=True, exist_ok=True)
    
    # Find materials database
    materials_files = [
        DATA_PATH / "databases" / "PRISM_MATERIALS_MASTER.json",
        PRISM_ROOT / "extracted" / "materials" / "materials_master_complete.json",
        DATA_PATH / "databases" / "PRISM_MATERIALS_EXPORT.json"
    ]
    
    materials_data = []
    for mf in materials_files:
        if mf.exists():
            with open(mf, "r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    materials_data = data
                    break
                elif isinstance(data, dict) and "materials" in data:
                    materials_data = data["materials"]
                    break
    
    if not materials_data:
        print("  No materials database found")
        return 0
    
    count = 0
    categories = {}
    
    for mat in materials_data[:200]:  # Limit to first 200 for performance
        mat_id = mat.get("material_id", mat.get("id", f"MAT-{count}"))
        name = mat.get("name", mat_id)
        category = mat.get("category", mat.get("iso_group", "Unknown"))
        
        # Track categories
        if category not in categories:
            categories[category] = []
        categories[category].append(name)
        
        # Generate note
        note_content = MATERIAL_TEMPLATE.format(
            name=name,
            material_id=mat_id,
            category=category,
            iso_group=mat.get("iso_group", "N/A"),
            density=mat.get("density", "N/A"),
            kc1_1=mat.get("kc1_1", mat.get("kienzle", {}).get("kc1_1", "N/A")),
            mc=mat.get("mc", mat.get("kienzle", {}).get("mc", "N/A")),
            n_taylor=mat.get("n_taylor", mat.get("taylor", {}).get("n", "N/A")),
            related_links="- " + "\n- ".join(create_wikilink(m) for m in categories.get(category, [])[:5] if m != name) or "- None",
            tags=f"#material #{sanitize_filename(category).lower().replace(' ', '-')}"
        )
        
        note_path = materials_kb_path / f"{sanitize_filename(name)}.md"
        with open(note_path, "w", encoding="utf-8") as f:
            f.write(note_content)
        
        count += 1
    
    # Create index
    index_content = f"""# Materials Index

## Overview
Total materials documented: {count}

## By Category
"""
    
    for cat in sorted(categories.keys()):
        index_content += f"\n### {cat} ({len(categories[cat])})\n"
        for mat in sorted(categories[cat])[:10]:
            index_content += f"- {create_wikilink(mat)}\n"
        if len(categories[cat]) > 10:
            index_content += f"- *...and {len(categories[cat]) - 10} more*\n"
    
    index_path = materials_kb_path / "_Index.md"
    with open(index_path, "w", encoding="utf-8") as f:
        f.write(index_content)
    
    return count


def generate_session_note() -> bool:
    """Generate note from current session state."""
    sessions_path = KNOWLEDGE_PATH / "Sessions"
    sessions_path.mkdir(parents=True, exist_ok=True)
    
    state_file = STATE_PATH / "CURRENT_STATE.json"
    if not state_file.exists():
        print("  No CURRENT_STATE.json found")
        return False
    
    with open(state_file, "r", encoding="utf-8") as f:
        state = json.load(f)
    
    session = state.get("currentSession", {})
    session_id = session.get("id", "UNKNOWN")
    
    note_content = SESSION_TEMPLATE.format(
        session_id=session_id,
        date=state.get("lastUpdated", datetime.now().isoformat())[:10],
        status=session.get("status", "UNKNOWN"),
        phase=session.get("phase", "N/A"),
        quick_resume=state.get("quickResume", "No resume information"),
        tasks=state.get("currentTask", {}).get("name", "No task recorded"),
        status_tag=session.get("status", "unknown").lower().replace("_", "-")
    )
    
    note_path = sessions_path / f"{sanitize_filename(session_id)}.md"
    with open(note_path, "w", encoding="utf-8") as f:
        f.write(note_content)
    
    return True


def generate_all() -> Dict[str, int]:
    """Generate all Obsidian notes."""
    print("=" * 60)
    print("PRISM Obsidian Note Generator")
    print("=" * 60)
    
    results = {}
    
    # Skills
    print("\n[SKILLS] Generating skill notes...")
    results["skills"] = generate_skill_notes()
    print(f"  âœ“ Generated {results['skills']} skill notes")
    
    # Materials
    print("\n[MATERIALS] Generating material notes...")
    results["materials"] = generate_material_notes()
    print(f"  âœ“ Generated {results['materials']} material notes")
    
    # Session
    print("\n[SESSION] Generating session note...")
    if generate_session_note():
        results["sessions"] = 1
        print("  âœ“ Generated session note")
    else:
        results["sessions"] = 0
    
    # Summary
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Knowledge vault: {KNOWLEDGE_PATH}")
    print(f"Skills notes: {results['skills']}")
    print(f"Material notes: {results['materials']}")
    print(f"Session notes: {results['sessions']}")
    print(f"\nOpen in Obsidian: File â†’ Open folder as vault â†’ {KNOWLEDGE_PATH}")
    
    return results


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate Obsidian notes from PRISM data")
    parser.add_argument("--skills", "-s", action="store_true", help="Generate skill notes only")
    parser.add_argument("--materials", "-m", action="store_true", help="Generate material notes only")
    parser.add_argument("--sessions", "-e", action="store_true", help="Generate session note only")
    
    args = parser.parse_args()
    
    if args.skills:
        count = generate_skill_notes()
        print(f"Generated {count} skill notes")
    elif args.materials:
        count = generate_material_notes()
        print(f"Generated {count} material notes")
    elif args.sessions:
        if generate_session_note():
            print("Generated session note")
        else:
            print("Failed to generate session note")
    else:
        generate_all()


if __name__ == "__main__":
    main()


