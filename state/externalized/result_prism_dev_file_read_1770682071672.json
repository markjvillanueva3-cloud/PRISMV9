{"path":"dist/index.js","total_lines":92598,"showing":"1-101","content":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key2 of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key2) && key2 !== except)\n        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// node_modules/depd/index.js\nvar require_depd = __commonJS({\n  \"node_modules/depd/index.js\"(exports2, module2) {\n    var relative2 = require(\"path\").relative;\n    module2.exports = depd;\n    var basePath = process.cwd();\n    function containsNamespace(str, namespace) {\n      var vals = str.split(/[ ,]+/);\n      var ns = String(namespace).toLowerCase();\n      for (var i = 0; i < vals.length; i++) {\n        var val = vals[i];\n        if (val && (val === \"*\" || val.toLowerCase() === ns)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function convertDataDescriptorToAccessor(obj, prop, message) {\n      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n      var value = descriptor.value;\n      descriptor.get = function getter() {\n        return value;\n      };\n      if (descriptor.writable) {\n        descriptor.set = function setter(val) {\n          return value = val;\n        };\n      }\n      delete descriptor.value;\n      delete descriptor.writable;\n      Object.defineProperty(obj, prop, descriptor);\n      return descriptor;\n    }\n    function createArgumentsString(arity) {\n      var str = \"\";\n      for (var i = 0; i < arity; i++) {\n        str += \", arg\" + i;\n      }\n      return str.substr(2);\n    }\n    function createStackString(stack) {\n      var str = this.name + \": \" + this.namespace;\n      if (this.message) {\n        str += \" deprecated \" + this.message;\n      }\n      for (var i = 0; i < stack.length; i++) {\n        str += \"\\n    at \" + stack[i].toString();\n      }\n      return str;\n    }\n    function depd(namespace) {\n      if (!namespace) {\n        throw new TypeError(\"argument namespace is required\");\n      }\n      var stack = getStack();\n      var site = callSiteLocation(stack[1]);\n      var file = site[0];\n      function deprecate(message) {\n        log2.call(deprecate, message);\n      }\n      deprecate._file = file;\n      deprecate._ignored = isignored(namespace);\n      deprecate._namespace = namespace;\n      deprecate._traced = istraced(namespace);\n      deprecate._warned = /* @__PURE__ */ Object.create(null);\n      deprecate.function = wrapfunction;\n      deprecate.property = wrapproperty;"}