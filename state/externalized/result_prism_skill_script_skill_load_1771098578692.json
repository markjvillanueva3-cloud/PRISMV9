{"success":true,"skill":{"skill_id":"prism-hook-system","name":"Hook System","filename":"SKILL.md","category":"core_development","description":"Hook-based automatic enforcement system for PRISM Manufacturing Intelligence. 155 hook points across 26 categories. 15 system hooks auto-enforce all 8 Laws and key Commandments. v1.2 adds Coordination category for F-PSI-001. Level 0 Always-On skill - hooks fire automatically on every operation. Key ","version":"1.0.0","path":"C:\\PRISM\\skills-consolidated\\prism-hook-system\\SKILL.md","lines":618,"size_bytes":18855,"triggers":[],"use_cases":[],"dependencies":[],"required_by":[],"tags":["hook","system"],"priority":5,"status":"active","enabled":true,"created":"2026-01-01","updated":"2026-02-01"},"content":"---\r\nname: prism-hook-system\r\ndescription: |\r\n  Hook-based automatic enforcement system for PRISM Manufacturing Intelligence.\r\n  155 hook points across 26 categories. 15 system hooks auto-enforce all 8 Laws\r\n  and key Commandments. v1.2 adds Coordination category for F-PSI-001.\r\n  Level 0 Always-On skill - hooks fire automatically on every operation.\r\n  Key principle: If it can be forgotten, it must be automated.\r\n---\r\n# PRISM HOOK SYSTEM v1.2\r\n## LEVEL 0 ALWAYS-ON - AUTOMATIC ENFORCEMENT\r\n## 155 Hooks | 26 Categories | 15 System Hooks\r\n\r\n---\r\n\r\n# CORE PRINCIPLE\r\n\r\n**If it can be forgotten, it MUST be automated.**\r\n\r\nHooks transform manual discipline into architectural guarantees. When hooks are active:\r\n- Laws are BLOCKED if violated, not just warned\r\n- Uncertainty is AUTO-INJECTED if missing\r\n- Predictions are AUTO-LOGGED for calibration\r\n- Learnings are AUTO-EXTRACTED after tasks\r\n\r\n---\r\n\r\n# WHEN TO USE\r\n\r\n- When implementing ANY new module (hooks provide lifecycle)\r\n- When enforcing Laws/Commandments automatically\r\n- When adding validation or processing\r\n- When integrating plugins or external systems\r\n- When tracking metrics, learning, or calibration\r\n- When planning tasks (hooks affect effort/time estimates)\r\n\r\n---\r\n\r\n# QUICK REFERENCE\r\n\r\n## Execute Hooks\r\n```typescript\r\nimport { executeHooks } from '@prism/core/hooks';\r\n\r\nconst result = await executeHooks('task:start', payload, context);\r\nif (result.aborted) {\r\n  console.error('BLOCKED:', result.abortReason);\r\n}\r\n```\r\n\r\n## Register Custom Hook\r\n```typescript\r\nimport { registerHook, PRIORITY } from '@prism/core/hooks';\r\n\r\nregisterHook('my-hook', 'db:preWrite', handler, {\r\n  priority: PRIORITY.BUSINESS_RULES\r\n});\r\n```\r\n\r\n---\r\n\r\n# 15 SYSTEM HOOKS (Cannot Disable)\r\n\r\nThese auto-enforce Laws and Commandments:\r\n\r\n| ID | Enforces | Priority | Effect |\r\n|----|----------|----------|--------|\r\n| SYS-LAW1-SAFETY | Law 1 | 0 | BLOCKS if S(x) < 0.70 |\r\n| SYS-LAW2-MICROSESSION | Law 2 | 32 | Requires MATHPLAN |\r\n| SYS-LAW3-COMPLETENESS | Law 3 | 33 | BLOCKS if C(T) < 1.0 |\r\n| SYS-LAW4-REGRESSION | Law 4 | 20 | BLOCKS data loss |\r\n| SYS-LAW5-PREDICTIVE | Law 5 | 30 | Requires failure analysis |\r\n| SYS-LAW6-CONTINUITY | Law 6 | 10 | Enforces state loading |\r\n| SYS-LAW7-VERIFICATION | Law 7 | 0 | Requires 95% confidence |\r\n| SYS-LAW8-MATH-EVOLUTION | Law 8 | 60 | BLOCKS if M(x) < 0.60 |\r\n| SYS-MATHPLAN-GATE | Law 2+8 | 5 | Validates MATHPLAN completeness |\r\n| SYS-CMD1-WIRING | Cmd 1 | 110 | Requires 6-8 consumers |\r\n| SYS-CMD5-UNCERTAINTY | Cmd 5 | 60 | AUTO-INJECTS uncertainty |\r\n| SYS-PREDICTION-LOG | Law 8 | 200 | AUTO-LOGS predictions |\r\n| SYS-CALIBRATION-MONITOR | Law 8 | 220 | Monitors formula health |\r\n| SYS-LEARNING-EXTRACT | Cmd 14 | 170 | AUTO-EXTRACTS learnings |\r\n| SYS-BUFFER-ZONE | Law 2 | 0 | BLOCKS at 19+ calls |\r\n\r\n---\r\n\r\n# 25 HOOK CATEGORIES (147 Total)\r\n\r\n## Base Categories (107 hooks)\r\n\r\n| Category | Count | Key Hook Points |\r\n|----------|-------|-----------------|\r\n| Session | 7 | preStart, postStart, preEnd, postCompact, heartbeat |\r\n| Task | 10 | prePlan, mathPlanValidate, start, checkpoint, complete |\r\n| Microsession | 5 | start, progress, bufferWarning, complete |\r\n| Database | 10 | preValidate, antiRegressionCheck, consumerWiringCheck |\r\n| Material | 6 | completenessCheck, cascade, crossValidate |\r\n| Calculation | 8 | dimensionalCheck, safetyBoundsCheck, uncertaintyInject, xaiExplain |\r\n| Formula | 8 | calibrationCheck, coefficientUpdate, upgrade |\r\n| Prediction | 5 | create, recordActual, triggerCalibration |\r\n| Agent | 6 | preExecute, postExecute, costTrack |\r\n| Swarm | 6 | preStart, progress, synthesize, complete |\r\n| Ralph | 6 | iterationStart, completionCheck, exhausted |\r\n| Learning | 7 | extract, match, apply, deepAnalysis, propagate |\r\n| Verification | 5 | start, levelComplete, chainComplete |\r\n| Quality | 4 | gateCheck, gateAggregate, blocked |\r\n| Skill | 4 | detect, load, execute |\r\n| Script | 4 | preExecute, postExecute, error |\r\n| Plugin | 6 | preAction, browserAction, filesystemAction |\r\n\r\n## Extended Categories (40 hooks) - v1.1\r\n\r\n| Category | Count | Purpose |\r\n|----------|-------|---------|\r\n| Transaction | 5 | Atomic operations, rollback |\r\n| Health | 5 | System monitoring, alerts |\r\n| Cache | 5 | Performance optimization |\r\n| Circuit Breaker | 4 | Resilience, recovery |\r\n| Rate Limiting | 4 | Throttling, quotas |\r\n| Audit Trail | 4 | Governance, compliance |\r\n| Coordination | 8 | F-PSI-001, resource selection, synergy calc (NEW v6.0) |\r\n| Feature Flag | 4 | Deployment control |\r\n| MCP Integration | 5 | Tool connectivity |\r\n| Planning Integration | 4 | Estimation overhead |\r\n\r\n---\r\n\r\n# KEY HOOK TRIGGERS (Automatic)\r\n\r\n| When | Hooks Fire | Effect |\r\n|------|-----------|--------|\r\n| Session starts | `session:preStart` | State loading enforced |\r\n| Before any task | `task:prePlan`, `task:mathPlanValidate` | MATHPLAN gate checked |\r\n| During work | `microsession:bufferWarning` | Buffer zone alerts |\r\n| DB changes | `db:antiRegressionCheck` | Data loss BLOCKED |\r\n| Any calculation | `calc:uncertaintyInject` | Uncertainty auto-added |\r\n| Task completes | `verification:chainComplete` | 95% confidence required |\r\n| After task | `learning:extract` | Patterns captured |\r\n| Context compacts | `session:postCompact` | State preserved |\r\n\r\n---\r\n\r\n# PRIORITY LEVELS (0-999)\r\n\r\n```\r\n0-29:    SYSTEM_CRITICAL (SAFETY, MATHPLAN, STATE, BUFFER_ZONE)\r\n30-49:   LAW_ENFORCEMENT (Laws 2-6)\r\n50-99:   VALIDATION (Schema, Uncertainty, Dimensional, Bounds)\r\n100-199: BUSINESS_LOGIC + INTELLIGENCE (Wiring, Learning, Knowledge)\r\n200-299: METRICS + MONITORING (Calibration, Performance)\r\n300-399: USER_HOOKS (Custom handlers)\r\n400-499: PLUGIN_HOOKS (Extensions)\r\n900-999: CLEANUP + LOGGING (Final processing)\r\n```\r\n\r\n---\r\n\r\n# PLANNING FORMULAS v2.0 (Hook-Aware)\r\n\r\n## F-PLAN-002: Effort Estimation\r\n```\r\nEFFORT = Sum(Base x Complexity x Risk) x HOOK_FACTOR x COORD_FACTOR x VERIFY_FACTOR\r\n\r\nHOOK_FACTOR = 1 + (n_hooks x t_hook / t_avg)     // ~1.005-1.15\r\nCOORD_FACTOR = 1 + (agents-1) x k_coord          // ~1.05 per agent\r\nVERIFY_FACTOR = 1 + (levels x k_verify)          // ~1.08 per level\r\n```\r\n\r\n## F-PLAN-005: Time Estimation\r\n```\r\nTIME = EFFORT x AVG_TIME x BUFFER + LATENCY_OVERHEAD\r\n\r\nLATENCY_OVERHEAD = t_state + t_context + (levels x t_verify) + t_learn\r\n                 = 50ms + 100ms + (levels x 200ms) + 150ms\r\n```\r\n\r\n## Hook-Related Coefficients (9)\r\n\r\n| ID | Name | Value | Unit |\r\n|----|------|-------|------|\r\n| K-HOOK-001 | Hook Execution Time | 5 +/- 2 | ms |\r\n| K-HOOK-002 | Hooks Per Operation | 3.2 +/- 0.8 | hooks/op |\r\n| K-COORD-001 | Agent Coordination | 0.05 +/- 0.02 | factor |\r\n| K-VERIFY-001 | Verification Level | 0.08 +/- 0.03 | factor |\r\n| K-LEARN-001 | Learning Extraction | 0.03 +/- 0.01 | factor |\r\n| K-LATENCY-001 | State Load | 50 +/- 20 | ms |\r\n| K-LATENCY-002 | Context Build | 100 +/- 40 | ms |\r\n| K-LATENCY-003 | Verification Latency | 200 +/- 80 | ms/level |\r\n| K-LATENCY-004 | Learning Latency | 150 +/- 50 | ms |\r\n\r\n---\r\n\r\n# HOOK EXECUTION FLOW\r\n\r\n```\r\nOPERATION START\r\n     |\r\n     v\r\n+-----------------+\r\n| Pre-hooks       | <-- Can BLOCK (return continue: false)\r\n| (priority 0->N) |     Can MODIFY payload\r\n+-----------------+\r\n         | continue: true\r\n         v\r\n+-----------------+\r\n| OPERATION       |\r\n+-----------------+\r\n         |\r\n         v\r\n+-----------------+\r\n| Post-hooks      | <-- Can LOG, LEARN, ALERT\r\n| (priority 0->N) |     Can trigger cascades\r\n+-----------------+\r\n         |\r\n         v\r\n    OPERATION END\r\n```\r\n\r\n---\r\n\r\n# FORMULA CALIBRATION ALERTS\r\n\r\n| Alert | Condition | Hook |\r\n|-------|-----------|------|\r\n| CRITICAL | MAPE > 50% or Bias > 25% | formula:calibrationCheck BLOCKS |\r\n| WARNING | MAPE > 20% or Bias > 10% | prediction:triggerCalibration |\r\n| NOTICE | Calibration > 30 days | SYS-CALIBRATION-MONITOR alerts |\r\n| HEALTHY | All metrics in bounds | Continue |\r\n\r\n---\r\n\r\n# PYTHON INTEGRATION\r\n\r\n```python\r\nfrom prism_hooks import hooks, HookPriority\r\n\r\n# Execute hooks\r\nresult = hooks.execute('agent:preExecute', payload, context)\r\nif result.blocked:\r\n    print(f\"BLOCKED: {result.abort_reason}\")\r\n\r\n# Register custom hook\r\nhooks.register('my-hook', 'task:start', my_handler, HookPriority.USER)\r\n\r\n# Get statistics\r\nprint(hooks.stats())\r\n```\r\n\r\n---\r\n\r\n# FILES\r\n\r\n```\r\nC:\\PRISM\\src\\core\\hooks\\\r\n  HookSystem.types.ts      # 1,905 lines - Base types (107 hooks)\r\n  HookSystem.extended.ts   # 684 lines - Extended types (40 hooks)\r\n  HookManager.ts           # 739 lines - Runtime engine\r\n  index.ts                 # Public API\r\n\r\nC:\\PRISM\\scripts\\\r\n  prism_hooks.py           # 635 lines - Python integration\r\n```\r\n\r\n---\r\n\r\n# COMMON PATTERNS\r\n\r\n## Block on Validation Failure\r\n```typescript\r\nregisterHook('block-invalid', 'material:preValidate',\r\n  async (payload) => {\r\n    if (payload.material.parameters.length < 50) {\r\n      return {\r\n        continue: false,\r\n        abortReason: 'Material has insufficient parameters',\r\n        abortSeverity: 'ERROR'\r\n      };\r\n    }\r\n    return { continue: true };\r\n  },\r\n  { priority: PRIORITY.VALIDATION }\r\n);\r\n```\r\n\r\n## Add Warning Without Blocking\r\n```typescript\r\nregisterHook('warn-high-hardness', 'material:preValidate',\r\n  async (payload) => {\r\n    if (payload.material.hardness > 60) {\r\n      return {\r\n        continue: true,\r\n        warnings: ['High hardness - verify tool selection']\r\n      };\r\n    }\r\n    return { continue: true };\r\n  },\r\n  { priority: PRIORITY.BUSINESS_RULES }\r\n);\r\n```\r\n\r\n---\r\n\r\n# INTEGRATION WITH ORCHESTRATORS\r\n\r\nThe Python orchestrators automatically integrate with hooks:\r\n\r\n```powershell\r\n# 56-agent swarm - fires agent:*, swarm:* hooks\r\npy -3 C:\\PRISM\\scripts\\prism_unified_system_v5.py --intelligent \"Task\"\r\n\r\n# Manufacturing analysis - fires agent:* hooks  \r\npy -3 C:\\PRISM\\scripts\\prism_orchestrator_v2.py --manufacturing \"Material\" \"Op\"\r\n\r\n# Ralph loop - fires ralph:* hooks\r\npy -3 C:\\PRISM\\scripts\\prism_unified_system_v5.py --ralph agent \"Prompt\" N\r\n```\r\n\r\n---\r\n\r\n# RELATED SKILLS\r\n\r\n- prism-sp-brainstorm.md -> task:prePlan hooks\r\n- prism-sp-execution.md -> task:checkpoint hooks\r\n- prism-sp-verification.md -> verification:* hooks\r\n- prism-formula-evolution.md -> formula:*, prediction:* hooks\r\n- prism-mathematical-planning.md -> planning:* hooks\r\n- prism-deep-learning.md -> learning:* hooks\r\n\r\n---\r\n\r\n# ENFORCEMENT SUMMARY\r\n\r\n## HARD RULES (Hooks BLOCK violations)\r\n\r\n- S(x) < 0.70 -> SYS-LAW1-SAFETY BLOCKS\r\n- M(x) < 0.60 -> SYS-LAW8-MATH-EVOLUTION BLOCKS\r\n- C(T) < 1.0 -> SYS-LAW3-COMPLETENESS BLOCKS\r\n- No MATHPLAN -> SYS-MATHPLAN-GATE BLOCKS\r\n- Data loss -> SYS-LAW4-REGRESSION BLOCKS\r\n- 19+ calls -> SYS-BUFFER-ZONE BLOCKS\r\n\r\n## SOFT RULES (Hooks WARN/AUTO-FIX)\r\n\r\n- Missing uncertainty -> SYS-CMD5-UNCERTAINTY injects\r\n- Missing predictions -> SYS-PREDICTION-LOG captures\r\n- Missing learnings -> SYS-LEARNING-EXTRACT captures\r\n- Stale calibration -> SYS-CALIBRATION-MONITOR alerts\r\n\r\n---\r\n\r\n**HOOKS = AUTOMATIC ENFORCEMENT. LIVES DEPEND ON ARCHITECTURAL GUARANTEES.**\r\n\r\n\r\n---\r\n\r\n# ERROR HANDLING\r\n\r\n## Hook Execution Errors\r\n\r\n| Error | Cause | Recovery |\r\n|-------|-------|----------|\r\n| HOOK_TIMEOUT | Handler exceeds 5s | Skip hook, log warning |\r\n| HOOK_EXCEPTION | Handler throws | Catch, log, continue if non-critical |\r\n| CIRCULAR_TRIGGER | Hook triggers itself | Detection + BLOCK |\r\n| PRIORITY_CONFLICT | Same priority registration | Earlier registration wins |\r\n| INVALID_PAYLOAD | Malformed data | Reject with validation error |\r\n\r\n## Error Handling Pattern\r\n```typescript\r\nasync function safeExecuteHook(hook: Hook, payload: any): Promise<HookResult> {\r\n  const timeout = hook.timeout ?? 5000;\r\n  \r\n  try {\r\n    const result = await Promise.race([\r\n      hook.handler(payload),\r\n      new Promise((_, reject) => \r\n        setTimeout(() => reject(new Error('HOOK_TIMEOUT')), timeout)\r\n      )\r\n    ]);\r\n    \r\n    return result;\r\n    \r\n  } catch (error) {\r\n    if (hook.required) {\r\n      // Critical hook - must succeed\r\n      throw new HookExecutionError(hook.id, error);\r\n    }\r\n    \r\n    // Non-critical - log and continue\r\n    console.warn(`Hook ${hook.id} failed: ${error.message}`);\r\n    return { continue: true, warnings: [`Hook ${hook.id} skipped due to error`] };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# SAFETY INTEGRATION\r\n\r\n## Safety-Critical Hooks\r\n\r\n| Hook | Safety Role | Priority |\r\n|------|-------------|----------|\r\n| SYS-LAW1-SAFETY | Blocks S(x) < 0.70 | 0 (highest) |\r\n| SYS-BUFFER-ZONE | Prevents context overflow | 0 |\r\n| SYS-LAW4-REGRESSION | Prevents data loss | 20 |\r\n| calc:safetyBoundsCheck | Validates output ranges | 50 |\r\n| material:safetyValidate | Ensures material safety | 50 |\r\n\r\n## Safety Hook Implementation\r\n```typescript\r\n// SYS-LAW1-SAFETY implementation\r\nregisterSystemHook('SYS-LAW1-SAFETY', 'calc:preExecute',\r\n  async (payload) => {\r\n    const safetyScore = computeSafetyScore(payload);\r\n    \r\n    if (safetyScore < 0.70) {\r\n      return {\r\n        continue: false,\r\n        abortReason: `SAFETY VIOLATION: S(x) = ${safetyScore.toFixed(2)} < 0.70`,\r\n        abortSeverity: 'CRITICAL',\r\n        requiresUserAction: true\r\n      };\r\n    }\r\n    \r\n    // Log for monitoring\r\n    await logSafetyMetric(payload.taskId, safetyScore);\r\n    \r\n    return { \r\n      continue: true,\r\n      metadata: { safetyScore }\r\n    };\r\n  },\r\n  { \r\n    priority: 0,  // Highest priority\r\n    required: true,\r\n    cannotDisable: true\r\n  }\r\n);\r\n```\r\n\r\n---\r\n\r\n# COMPLETE EXAMPLES\r\n\r\n## Example 1: Material Validation Pipeline\r\n```typescript\r\n// Register material validation hooks\r\nconst materialHooks = [\r\n  {\r\n    id: 'material-schema-validate',\r\n    point: 'material:preValidate',\r\n    handler: async (payload) => {\r\n      const errors = validateSchema(payload.material, MATERIAL_SCHEMA_127);\r\n      if (errors.length > 0) {\r\n        return { continue: false, abortReason: errors.join(', ') };\r\n      }\r\n      return { continue: true };\r\n    },\r\n    priority: 50\r\n  },\r\n  {\r\n    id: 'material-physics-check',\r\n    point: 'material:preValidate',\r\n    handler: async (payload) => {\r\n      const warnings = checkPhysicsConsistency(payload.material);\r\n      return { continue: true, warnings };\r\n    },\r\n    priority: 60\r\n  },\r\n  {\r\n    id: 'material-completeness',\r\n    point: 'material:postValidate',\r\n    handler: async (payload) => {\r\n      const grade = computeMaterialGrade(payload.material);\r\n      payload.material.grade = grade;\r\n      return { continue: true, modified: true };\r\n    },\r\n    priority: 100\r\n  }\r\n];\r\n\r\nmaterialHooks.forEach(h => registerHook(h.id, h.point, h.handler, { priority: h.priority }));\r\n```\r\n\r\n## Example 2: Task Execution with All Hooks\r\n```typescript\r\nasync function executeTask(task: Task) {\r\n  // Pre-plan hooks (MATHPLAN gate)\r\n  let result = await executeHooks('task:prePlan', { task });\r\n  if (result.aborted) throw new Error(result.abortReason);\r\n  \r\n  // MATHPLAN validation\r\n  result = await executeHooks('task:mathPlanValidate', { task, plan: result.plan });\r\n  if (result.aborted) throw new Error(result.abortReason);\r\n  \r\n  // Start hooks\r\n  result = await executeHooks('task:start', { task });\r\n  \r\n  try {\r\n    // Execute with checkpoints\r\n    for (const step of task.steps) {\r\n      result = await executeHooks('task:checkpoint', { task, step });\r\n      if (result.aborted) break;\r\n      \r\n      await executeStep(step);\r\n    }\r\n    \r\n    // Completion hooks\r\n    await executeHooks('task:complete', { task, success: true });\r\n    \r\n    // Verification chain\r\n    await executeHooks('verification:chainComplete', { task });\r\n    \r\n    // Learning extraction\r\n    await executeHooks('learning:extract', { task });\r\n    \r\n  } catch (error) {\r\n    await executeHooks('task:error', { task, error });\r\n    throw error;\r\n  }\r\n}\r\n```\r\n\r\n## Example 3: Swarm Coordination Hooks\r\n```typescript\r\nasync function runSwarm(swarmConfig: SwarmConfig) {\r\n  // Pre-start validation\r\n  await executeHooks('swarm:preStart', { config: swarmConfig });\r\n  \r\n  // Initialize agents\r\n  for (const agent of swarmConfig.agents) {\r\n    await executeHooks('agent:preExecute', { agent });\r\n  }\r\n  \r\n  // Run swarm with progress tracking\r\n  let iteration = 0;\r\n  while (!swarmComplete(swarmConfig)) {\r\n    iteration++;\r\n    \r\n    // Progress hook\r\n    await executeHooks('swarm:progress', { \r\n      iteration, \r\n      progress: calculateProgress(swarmConfig) \r\n    });\r\n    \r\n    // Check buffer zone\r\n    const bufferResult = await executeHooks('microsession:bufferWarning', {\r\n      toolCalls: getToolCallCount(),\r\n      threshold: 15\r\n    });\r\n    \r\n    if (bufferResult.aborted) {\r\n      // Save checkpoint and pause\r\n      await executeHooks('task:checkpoint', { reason: 'buffer_warning' });\r\n      break;\r\n    }\r\n    \r\n    await executeSwarmIteration(swarmConfig, iteration);\r\n  }\r\n  \r\n  // Synthesis and completion\r\n  await executeHooks('swarm:synthesize', { results: getSwarmResults() });\r\n  await executeHooks('swarm:complete', { swarmConfig });\r\n}\r\n```\r\n\r\n---\r\n\r\n# MONITORING DASHBOARD\r\n\r\n## Hook Statistics Query\r\n```typescript\r\nfunction getHookStatistics(): HookStatistics {\r\n  return {\r\n    totalExecutions: hookMetrics.totalExecutions,\r\n    blockedOperations: hookMetrics.blocked,\r\n    averageLatency: hookMetrics.totalLatency / hookMetrics.totalExecutions,\r\n    byCategory: Object.fromEntries(\r\n      CATEGORIES.map(c => [c, hookMetrics.byCategory[c]])\r\n    ),\r\n    systemHookTriggers: {\r\n      'SYS-LAW1-SAFETY': hookMetrics.systemHooks['SYS-LAW1-SAFETY'],\r\n      'SYS-LAW4-REGRESSION': hookMetrics.systemHooks['SYS-LAW4-REGRESSION'],\r\n      'SYS-BUFFER-ZONE': hookMetrics.systemHooks['SYS-BUFFER-ZONE']\r\n    },\r\n    lastHourBlocks: getRecentBlocks(3600)\r\n  };\r\n}\r\n```\r\n\r\n## Dashboard Output Example\r\n```\r\n═══════════════════════════════════════════════════════════════\r\nHOOK SYSTEM DASHBOARD - 2026-01-29T20:30:00Z\r\n═══════════════════════════════════════════════════════════════\r\nTotal Executions:     12,847\r\nBlocked Operations:   23 (0.18%)\r\nAverage Latency:      4.2ms\r\n\r\nTop Categories:\r\n  task:*              3,421 (26.6%)\r\n  calc:*              2,891 (22.5%)\r\n  verification:*      1,956 (15.2%)\r\n\r\nSystem Hook Triggers:\r\n  SYS-LAW1-SAFETY:    2 blocks (critical)\r\n  SYS-LAW4-REGRESSION: 8 blocks\r\n  SYS-BUFFER-ZONE:    13 blocks\r\n\r\nHealth: ✅ HEALTHY\r\n═══════════════════════════════════════════════════════════════\r\n```\r\n\r\n---\r\n\r\n**Version:** 1.3 | **Date:** 2026-01-29 | **Level:** 0 (Always-On)\r\n**Enhanced:** Error handling, safety integration, complete examples, monitoring\r\n","load_result":{"success":true,"skill_id":"prism-hook-system","content":"---\r\nname: prism-hook-system\r\ndescription: |\r\n  Hook-based automatic enforcement system for PRISM Manufacturing Intelligence.\r\n  155 hook points across 26 categories. 15 system hooks auto-enforce all 8 Laws\r\n  and key Commandments. v1.2 adds Coordination category for F-PSI-001.\r\n  Level 0 Always-On skill - hooks fire automatically on every operation.\r\n  Key principle: If it can be forgotten, it must be automated.\r\n---\r\n# PRISM HOOK SYSTEM v1.2\r\n## LEVEL 0 ALWAYS-ON - AUTOMATIC ENFORCEMENT\r\n## 155 Hooks | 26 Categories | 15 System Hooks\r\n\r\n---\r\n\r\n# CORE PRINCIPLE\r\n\r\n**If it can be forgotten, it MUST be automated.**\r\n\r\nHooks transform manual discipline into architectural guarantees. When hooks are active:\r\n- Laws are BLOCKED if violated, not just warned\r\n- Uncertainty is AUTO-INJECTED if missing\r\n- Predictions are AUTO-LOGGED for calibration\r\n- Learnings are AUTO-EXTRACTED after tasks\r\n\r\n---\r\n\r\n# WHEN TO USE\r\n\r\n- When implementing ANY new module (hooks provide lifecycle)\r\n- When enforcing Laws/Commandments automatically\r\n- When adding validation or processing\r\n- When integrating plugins or external systems\r\n- When tracking metrics, learning, or calibration\r\n- When planning tasks (hooks affect effort/time estimates)\r\n\r\n---\r\n\r\n# QUICK REFERENCE\r\n\r\n## Execute Hooks\r\n```typescript\r\nimport { executeHooks } from '@prism/core/hooks';\r\n\r\nconst result = await executeHooks('task:start', payload, context);\r\nif (result.aborted) {\r\n  console.error('BLOCKED:', result.abortReason);\r\n}\r\n```\r\n\r\n## Register Custom Hook\r\n```typescript\r\nimport { registerHook, PRIORITY } from '@prism/core/hooks';\r\n\r\nregisterHook('my-hook', 'db:preWrite', handler, {\r\n  priority: PRIORITY.BUSINESS_RULES\r\n});\r\n```\r\n\r\n---\r\n\r\n# 15 SYSTEM HOOKS (Cannot Disable)\r\n\r\nThese auto-enforce Laws and Commandments:\r\n\r\n| ID | Enforces | Priority | Effect |\r\n|----|----------|----------|--------|\r\n| SYS-LAW1-SAFETY | Law 1 | 0 | BLOCKS if S(x) < 0.70 |\r\n| SYS-LAW2-MICROSESSION | Law 2 | 32 | Requires MATHPLAN |\r\n| SYS-LAW3-COMPLETENESS | Law 3 | 33 | BLOCKS if C(T) < 1.0 |\r\n| SYS-LAW4-REGRESSION | Law 4 | 20 | BLOCKS data loss |\r\n| SYS-LAW5-PREDICTIVE | Law 5 | 30 | Requires failure analysis |\r\n| SYS-LAW6-CONTINUITY | Law 6 | 10 | Enforces state loading |\r\n| SYS-LAW7-VERIFICATION | Law 7 | 0 | Requires 95% confidence |\r\n| SYS-LAW8-MATH-EVOLUTION | Law 8 | 60 | BLOCKS if M(x) < 0.60 |\r\n| SYS-MATHPLAN-GATE | Law 2+8 | 5 | Validates MATHPLAN completeness |\r\n| SYS-CMD1-WIRING | Cmd 1 | 110 | Requires 6-8 consumers |\r\n| SYS-CMD5-UNCERTAINTY | Cmd 5 | 60 | AUTO-INJECTS uncertainty |\r\n| SYS-PREDICTION-LOG | Law 8 | 200 | AUTO-LOGS predictions |\r\n| SYS-CALIBRATION-MONITOR | Law 8 | 220 | Monitors formula health |\r\n| SYS-LEARNING-EXTRACT | Cmd 14 | 170 | AUTO-EXTRACTS learnings |\r\n| SYS-BUFFER-ZONE | Law 2 | 0 | BLOCKS at 19+ calls |\r\n\r\n---\r\n\r\n# 25 HOOK CATEGORIES (147 Total)\r\n\r\n## Base Categories (107 hooks)\r\n\r\n| Category | Count | Key Hook Points |\r\n|----------|-------|-----------------|\r\n| Session | 7 | preStart, postStart, preEnd, postCompact, heartbeat |\r\n| Task | 10 | prePlan, mathPlanValidate, start, checkpoint, complete |\r\n| Microsession | 5 | start, progress, bufferWarning, complete |\r\n| Database | 10 | preValidate, antiRegressionCheck, consumerWiringCheck |\r\n| Material | 6 | completenessCheck, cascade, crossValidate |\r\n| Calculation | 8 | dimensionalCheck, safetyBoundsCheck, uncertaintyInject, xaiExplain |\r\n| Formula | 8 | calibrationCheck, coefficientUpdate, upgrade |\r\n| Prediction | 5 | create, recordActual, triggerCalibration |\r\n| Agent | 6 | preExecute, postExecute, costTrack |\r\n| Swarm | 6 | preStart, progress, synthesize, complete |\r\n| Ralph | 6 | iterationStart, completionCheck, exhausted |\r\n| Learning | 7 | extract, match, apply, deepAnalysis, propagate |\r\n| Verification | 5 | start, levelComplete, chainComplete |\r\n| Quality | 4 | gateCheck, gateAggregate, blocked |\r\n| Skill | 4 | detect, load, execute |\r\n| Script | 4 | preExecute, postExecute, error |\r\n| Plugin | 6 | preAction, browserAction, filesystemAction |\r\n\r\n## Extended Categories (40 hooks) - v1.1\r\n\r\n| Category | Count | Purpose |\r\n|----------|-------|---------|\r\n| Transaction | 5 | Atomic operations, rollback |\r\n| Health | 5 | System monitoring, alerts |\r\n| Cache | 5 | Performance optimization |\r\n| Circuit Breaker | 4 | Resilience, recovery |\r\n| Rate Limiting | 4 | Throttling, quotas |\r\n| Audit Trail | 4 | Governance, compliance |\r\n| Coordination | 8 | F-PSI-001, resource selection, synergy calc (NEW v6.0) |\r\n| Feature Flag | 4 | Deployment control |\r\n| MCP Integration | 5 | Tool connectivity |\r\n| Planning Integration | 4 | Estimation overhead |\r\n\r\n---\r\n\r\n# KEY HOOK TRIGGERS (Automatic)\r\n\r\n| When | Hooks Fire | Effect |\r\n|------|-----------|--------|\r\n| Session starts | `session:preStart` | State loading enforced |\r\n| Before any task | `task:prePlan`, `task:mathPlanValidate` | MATHPLAN gate checked |\r\n| During work | `microsession:bufferWarning` | Buffer zone alerts |\r\n| DB changes | `db:antiRegressionCheck` | Data loss BLOCKED |\r\n| Any calculation | `calc:uncertaintyInject` | Uncertainty auto-added |\r\n| Task completes | `verification:chainComplete` | 95% confidence required |\r\n| After task | `learning:extract` | Patterns captured |\r\n| Context compacts | `session:postCompact` | State preserved |\r\n\r\n---\r\n\r\n# PRIORITY LEVELS (0-999)\r\n\r\n```\r\n0-29:    SYSTEM_CRITICAL (SAFETY, MATHPLAN, STATE, BUFFER_ZONE)\r\n30-49:   LAW_ENFORCEMENT (Laws 2-6)\r\n50-99:   VALIDATION (Schema, Uncertainty, Dimensional, Bounds)\r\n100-199: BUSINESS_LOGIC + INTELLIGENCE (Wiring, Learning, Knowledge)\r\n200-299: METRICS + MONITORING (Calibration, Performance)\r\n300-399: USER_HOOKS (Custom handlers)\r\n400-499: PLUGIN_HOOKS (Extensions)\r\n900-999: CLEANUP + LOGGING (Final processing)\r\n```\r\n\r\n---\r\n\r\n# PLANNING FORMULAS v2.0 (Hook-Aware)\r\n\r\n## F-PLAN-002: Effort Estimation\r\n```\r\nEFFORT = Sum(Base x Complexity x Risk) x HOOK_FACTOR x COORD_FACTOR x VERIFY_FACTOR\r\n\r\nHOOK_FACTOR = 1 + (n_hooks x t_hook / t_avg)     // ~1.005-1.15\r\nCOORD_FACTOR = 1 + (agents-1) x k_coord          // ~1.05 per agent\r\nVERIFY_FACTOR = 1 + (levels x k_verify)          // ~1.08 per level\r\n```\r\n\r\n## F-PLAN-005: Time Estimation\r\n```\r\nTIME = EFFORT x AVG_TIME x BUFFER + LATENCY_OVERHEAD\r\n\r\nLATENCY_OVERHEAD = t_state + t_context + (levels x t_verify) + t_learn\r\n                 = 50ms + 100ms + (levels x 200ms) + 150ms\r\n```\r\n\r\n## Hook-Related Coefficients (9)\r\n\r\n| ID | Name | Value | Unit |\r\n|----|------|-------|------|\r\n| K-HOOK-001 | Hook Execution Time | 5 +/- 2 | ms |\r\n| K-HOOK-002 | Hooks Per Operation | 3.2 +/- 0.8 | hooks/op |\r\n| K-COORD-001 | Agent Coordination | 0.05 +/- 0.02 | factor |\r\n| K-VERIFY-001 | Verification Level | 0.08 +/- 0.03 | factor |\r\n| K-LEARN-001 | Learning Extraction | 0.03 +/- 0.01 | factor |\r\n| K-LATENCY-001 | State Load | 50 +/- 20 | ms |\r\n| K-LATENCY-002 | Context Build | 100 +/- 40 | ms |\r\n| K-LATENCY-003 | Verification Latency | 200 +/- 80 | ms/level |\r\n| K-LATENCY-004 | Learning Latency | 150 +/- 50 | ms |\r\n\r\n---\r\n\r\n# HOOK EXECUTION FLOW\r\n\r\n```\r\nOPERATION START\r\n     |\r\n     v\r\n+-----------------+\r\n| Pre-hooks       | <-- Can BLOCK (return continue: false)\r\n| (priority 0->N) |     Can MODIFY payload\r\n+-----------------+\r\n         | continue: true\r\n         v\r\n+-----------------+\r\n| OPERATION       |\r\n+-----------------+\r\n         |\r\n         v\r\n+-----------------+\r\n| Post-hooks      | <-- Can LOG, LEARN, ALERT\r\n| (priority 0->N) |     Can trigger cascades\r\n+-----------------+\r\n         |\r\n         v\r\n    OPERATION END\r\n```\r\n\r\n---\r\n\r\n# FORMULA CALIBRATION ALERTS\r\n\r\n| Alert | Condition | Hook |\r\n|-------|-----------|------|\r\n| CRITICAL | MAPE > 50% or Bias > 25% | formula:calibrationCheck BLOCKS |\r\n| WARNING | MAPE > 20% or Bias > 10% | prediction:triggerCalibration |\r\n| NOTICE | Calibration > 30 days | SYS-CALIBRATION-MONITOR alerts |\r\n| HEALTHY | All metrics in bounds | Continue |\r\n\r\n---\r\n\r\n# PYTHON INTEGRATION\r\n\r\n```python\r\nfrom prism_hooks import hooks, HookPriority\r\n\r\n# Execute hooks\r\nresult = hooks.execute('agent:preExecute', payload, context)\r\nif result.blocked:\r\n    print(f\"BLOCKED: {result.abort_reason}\")\r\n\r\n# Register custom hook\r\nhooks.register('my-hook', 'task:start', my_handler, HookPriority.USER)\r\n\r\n# Get statistics\r\nprint(hooks.stats())\r\n```\r\n\r\n---\r\n\r\n# FILES\r\n\r\n```\r\nC:\\PRISM\\src\\core\\hooks\\\r\n  HookSystem.types.ts      # 1,905 lines - Base types (107 hooks)\r\n  HookSystem.extended.ts   # 684 lines - Extended types (40 hooks)\r\n  HookManager.ts           # 739 lines - Runtime engine\r\n  index.ts                 # Public API\r\n\r\nC:\\PRISM\\scripts\\\r\n  prism_hooks.py           # 635 lines - Python integration\r\n```\r\n\r\n---\r\n\r\n# COMMON PATTERNS\r\n\r\n## Block on Validation Failure\r\n```typescript\r\nregisterHook('block-invalid', 'material:preValidate',\r\n  async (payload) => {\r\n    if (payload.material.parameters.length < 50) {\r\n      return {\r\n        continue: false,\r\n        abortReason: 'Material has insufficient parameters',\r\n        abortSeverity: 'ERROR'\r\n      };\r\n    }\r\n    return { continue: true };\r\n  },\r\n  { priority: PRIORITY.VALIDATION }\r\n);\r\n```\r\n\r\n## Add Warning Without Blocking\r\n```typescript\r\nregisterHook('warn-high-hardness', 'material:preValidate',\r\n  async (payload) => {\r\n    if (payload.material.hardness > 60) {\r\n      return {\r\n        continue: true,\r\n        warnings: ['High hardness - verify tool selection']\r\n      };\r\n    }\r\n    return { continue: true };\r\n  },\r\n  { priority: PRIORITY.BUSINESS_RULES }\r\n);\r\n```\r\n\r\n---\r\n\r\n# INTEGRATION WITH ORCHESTRATORS\r\n\r\nThe Python orchestrators automatically integrate with hooks:\r\n\r\n```powershell\r\n# 56-agent swarm - fires agent:*, swarm:* hooks\r\npy -3 C:\\PRISM\\scripts\\prism_unified_system_v5.py --intelligent \"Task\"\r\n\r\n# Manufacturing analysis - fires agent:* hooks  \r\npy -3 C:\\PRISM\\scripts\\prism_orchestrator_v2.py --manufacturing \"Material\" \"Op\"\r\n\r\n# Ralph loop - fires ralph:* hooks\r\npy -3 C:\\PRISM\\scripts\\prism_unified_system_v5.py --ralph agent \"Prompt\" N\r\n```\r\n\r\n---\r\n\r\n# RELATED SKILLS\r\n\r\n- prism-sp-brainstorm.md -> task:prePlan hooks\r\n- prism-sp-execution.md -> task:checkpoint hooks\r\n- prism-sp-verification.md -> verification:* hooks\r\n- prism-formula-evolution.md -> formula:*, prediction:* hooks\r\n- prism-mathematical-planning.md -> planning:* hooks\r\n- prism-deep-learning.md -> learning:* hooks\r\n\r\n---\r\n\r\n# ENFORCEMENT SUMMARY\r\n\r\n## HARD RULES (Hooks BLOCK violations)\r\n\r\n- S(x) < 0.70 -> SYS-LAW1-SAFETY BLOCKS\r\n- M(x) < 0.60 -> SYS-LAW8-MATH-EVOLUTION BLOCKS\r\n- C(T) < 1.0 -> SYS-LAW3-COMPLETENESS BLOCKS\r\n- No MATHPLAN -> SYS-MATHPLAN-GATE BLOCKS\r\n- Data loss -> SYS-LAW4-REGRESSION BLOCKS\r\n- 19+ calls -> SYS-BUFFER-ZONE BLOCKS\r\n\r\n## SOFT RULES (Hooks WARN/AUTO-FIX)\r\n\r\n- Missing uncertainty -> SYS-CMD5-UNCERTAINTY injects\r\n- Missing predictions -> SYS-PREDICTION-LOG captures\r\n- Missing learnings -> SYS-LEARNING-EXTRACT captures\r\n- Stale calibration -> SYS-CALIBRATION-MONITOR alerts\r\n\r\n---\r\n\r\n**HOOKS = AUTOMATIC ENFORCEMENT. LIVES DEPEND ON ARCHITECTURAL GUARANTEES.**\r\n\r\n\r\n---\r\n\r\n# ERROR HANDLING\r\n\r\n## Hook Execution Errors\r\n\r\n| Error | Cause | Recovery |\r\n|-------|-------|----------|\r\n| HOOK_TIMEOUT | Handler exceeds 5s | Skip hook, log warning |\r\n| HOOK_EXCEPTION | Handler throws | Catch, log, continue if non-critical |\r\n| CIRCULAR_TRIGGER | Hook triggers itself | Detection + BLOCK |\r\n| PRIORITY_CONFLICT | Same priority registration | Earlier registration wins |\r\n| INVALID_PAYLOAD | Malformed data | Reject with validation error |\r\n\r\n## Error Handling Pattern\r\n```typescript\r\nasync function safeExecuteHook(hook: Hook, payload: any): Promise<HookResult> {\r\n  const timeout = hook.timeout ?? 5000;\r\n  \r\n  try {\r\n    const result = await Promise.race([\r\n      hook.handler(payload),\r\n      new Promise((_, reject) => \r\n        setTimeout(() => reject(new Error('HOOK_TIMEOUT')), timeout)\r\n      )\r\n    ]);\r\n    \r\n    return result;\r\n    \r\n  } catch (error) {\r\n    if (hook.required) {\r\n      // Critical hook - must succeed\r\n      throw new HookExecutionError(hook.id, error);\r\n    }\r\n    \r\n    // Non-critical - log and continue\r\n    console.warn(`Hook ${hook.id} failed: ${error.message}`);\r\n    return { continue: true, warnings: [`Hook ${hook.id} skipped due to error`] };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# SAFETY INTEGRATION\r\n\r\n## Safety-Critical Hooks\r\n\r\n| Hook | Safety Role | Priority |\r\n|------|-------------|----------|\r\n| SYS-LAW1-SAFETY | Blocks S(x) < 0.70 | 0 (highest) |\r\n| SYS-BUFFER-ZONE | Prevents context overflow | 0 |\r\n| SYS-LAW4-REGRESSION | Prevents data loss | 20 |\r\n| calc:safetyBoundsCheck | Validates output ranges | 50 |\r\n| material:safetyValidate | Ensures material safety | 50 |\r\n\r\n## Safety Hook Implementation\r\n```typescript\r\n// SYS-LAW1-SAFETY implementation\r\nregisterSystemHook('SYS-LAW1-SAFETY', 'calc:preExecute',\r\n  async (payload) => {\r\n    const safetyScore = computeSafetyScore(payload);\r\n    \r\n    if (safetyScore < 0.70) {\r\n      return {\r\n        continue: false,\r\n        abortReason: `SAFETY VIOLATION: S(x) = ${safetyScore.toFixed(2)} < 0.70`,\r\n        abortSeverity: 'CRITICAL',\r\n        requiresUserAction: true\r\n      };\r\n    }\r\n    \r\n    // Log for monitoring\r\n    await logSafetyMetric(payload.taskId, safetyScore);\r\n    \r\n    return { \r\n      continue: true,\r\n      metadata: { safetyScore }\r\n    };\r\n  },\r\n  { \r\n    priority: 0,  // Highest priority\r\n    required: true,\r\n    cannotDisable: true\r\n  }\r\n);\r\n```\r\n\r\n---\r\n\r\n# COMPLETE EXAMPLES\r\n\r\n## Example 1: Material Validation Pipeline\r\n```typescript\r\n// Register material validation hooks\r\nconst materialHooks = [\r\n  {\r\n    id: 'material-schema-validate',\r\n    point: 'material:preValidate',\r\n    handler: async (payload) => {\r\n      const errors = validateSchema(payload.material, MATERIAL_SCHEMA_127);\r\n      if (errors.length > 0) {\r\n        return { continue: false, abortReason: errors.join(', ') };\r\n      }\r\n      return { continue: true };\r\n    },\r\n    priority: 50\r\n  },\r\n  {\r\n    id: 'material-physics-check',\r\n    point: 'material:preValidate',\r\n    handler: async (payload) => {\r\n      const warnings = checkPhysicsConsistency(payload.material);\r\n      return { continue: true, warnings };\r\n    },\r\n    priority: 60\r\n  },\r\n  {\r\n    id: 'material-completeness',\r\n    point: 'material:postValidate',\r\n    handler: async (payload) => {\r\n      const grade = computeMaterialGrade(payload.material);\r\n      payload.material.grade = grade;\r\n      return { continue: true, modified: true };\r\n    },\r\n    priority: 100\r\n  }\r\n];\r\n\r\nmaterialHooks.forEach(h => registerHook(h.id, h.point, h.handler, { priority: h.priority }));\r\n```\r\n\r\n## Example 2: Task Execution with All Hooks\r\n```typescript\r\nasync function executeTask(task: Task) {\r\n  // Pre-plan hooks (MATHPLAN gate)\r\n  let result = await executeHooks('task:prePlan', { task });\r\n  if (result.aborted) throw new Error(result.abortReason);\r\n  \r\n  // MATHPLAN validation\r\n  result = await executeHooks('task:mathPlanValidate', { task, plan: result.plan });\r\n  if (result.aborted) throw new Error(result.abortReason);\r\n  \r\n  // Start hooks\r\n  result = await executeHooks('task:start', { task });\r\n  \r\n  try {\r\n    // Execute with checkpoints\r\n    for (const step of task.steps) {\r\n      result = await executeHooks('task:checkpoint', { task, step });\r\n      if (result.aborted) break;\r\n      \r\n      await executeStep(step);\r\n    }\r\n    \r\n    // Completion hooks\r\n    await executeHooks('task:complete', { task, success: true });\r\n    \r\n    // Verification chain\r\n    await executeHooks('verification:chainComplete', { task });\r\n    \r\n    // Learning extraction\r\n    await executeHooks('learning:extract', { task });\r\n    \r\n  } catch (error) {\r\n    await executeHooks('task:error', { task, error });\r\n    throw error;\r\n  }\r\n}\r\n```\r\n\r\n## Example 3: Swarm Coordination Hooks\r\n```typescript\r\nasync function runSwarm(swarmConfig: SwarmConfig) {\r\n  // Pre-start validation\r\n  await executeHooks('swarm:preStart', { config: swarmConfig });\r\n  \r\n  // Initialize agents\r\n  for (const agent of swarmConfig.agents) {\r\n    await executeHooks('agent:preExecute', { agent });\r\n  }\r\n  \r\n  // Run swarm with progress tracking\r\n  let iteration = 0;\r\n  while (!swarmComplete(swarmConfig)) {\r\n    iteration++;\r\n    \r\n    // Progress hook\r\n    await executeHooks('swarm:progress', { \r\n      iteration, \r\n      progress: calculateProgress(swarmConfig) \r\n    });\r\n    \r\n    // Check buffer zone\r\n    const bufferResult = await executeHooks('microsession:bufferWarning', {\r\n      toolCalls: getToolCallCount(),\r\n      threshold: 15\r\n    });\r\n    \r\n    if (bufferResult.aborted) {\r\n      // Save checkpoint and pause\r\n      await executeHooks('task:checkpoint', { reason: 'buffer_warning' });\r\n      break;\r\n    }\r\n    \r\n    await executeSwarmIteration(swarmConfig, iteration);\r\n  }\r\n  \r\n  // Synthesis and completion\r\n  await executeHooks('swarm:synthesize', { results: getSwarmResults() });\r\n  await executeHooks('swarm:complete', { swarmConfig });\r\n}\r\n```\r\n\r\n---\r\n\r\n# MONITORING DASHBOARD\r\n\r\n## Hook Statistics Query\r\n```typescript\r\nfunction getHookStatistics(): HookStatistics {\r\n  return {\r\n    totalExecutions: hookMetrics.totalExecutions,\r\n    blockedOperations: hookMetrics.blocked,\r\n    averageLatency: hookMetrics.totalLatency / hookMetrics.totalExecutions,\r\n    byCategory: Object.fromEntries(\r\n      CATEGORIES.map(c => [c, hookMetrics.byCategory[c]])\r\n    ),\r\n    systemHookTriggers: {\r\n      'SYS-LAW1-SAFETY': hookMetrics.systemHooks['SYS-LAW1-SAFETY'],\r\n      'SYS-LAW4-REGRESSION': hookMetrics.systemHooks['SYS-LAW4-REGRESSION'],\r\n      'SYS-BUFFER-ZONE': hookMetrics.systemHooks['SYS-BUFFER-ZONE']\r\n    },\r\n    lastHourBlocks: getRecentBlocks(3600)\r\n  };\r\n}\r\n```\r\n\r\n## Dashboard Output Example\r\n```\r\n═══════════════════════════════════════════════════════════════\r\nHOOK SYSTEM DASHBOARD - 2026-01-29T20:30:00Z\r\n═══════════════════════════════════════════════════════════════\r\nTotal Executions:     12,847\r\nBlocked Operations:   23 (0.18%)\r\nAverage Latency:      4.2ms\r\n\r\nTop Categories:\r\n  task:*              3,421 (26.6%)\r\n  calc:*              2,891 (22.5%)\r\n  verification:*      1,956 (15.2%)\r\n\r\nSystem Hook Triggers:\r\n  SYS-LAW1-SAFETY:    2 blocks (critical)\r\n  SYS-LAW4-REGRESSION: 8 blocks\r\n  SYS-BUFFER-ZONE:    13 blocks\r\n\r\nHealth: ✅ HEALTHY\r\n═══════════════════════════════════════════════════════════════\r\n```\r\n\r\n---\r\n\r\n**Version:** 1.3 | **Date:** 2026-01-29 | **Level:** 0 (Always-On)\r\n**Enhanced:** Error handling, safety integration, complete examples, monitoring\r\n","lines":618,"cached":false,"load_time_ms":1}}