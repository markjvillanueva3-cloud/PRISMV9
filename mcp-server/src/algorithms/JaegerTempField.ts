/**
 * Jaeger Temperature Field — Moving Heat Source Solution
 *
 * Implements Jaeger's (1942) analytical solution for the temperature field
 * generated by a moving band heat source on a semi-infinite body. Models
 * the transient temperature distribution in the workpiece during machining.
 *
 * The steady-state temperature rise at the surface under a moving rectangular
 * heat source of width 2a moving at velocity V is computed using the
 * complementary error function solution.
 *
 * Manufacturing uses: workpiece burn prediction, white layer formation risk,
 * grinding temperature estimation, residual stress from thermal effects.
 *
 * References:
 * - Jaeger, J.C. (1942). "Moving Sources of Heat and the Temperature at Sliding Contacts"
 * - Carslaw, H.S. & Jaeger, J.C. (1959). "Conduction of Heat in Solids"
 * - Komanduri, R. & Hou, Z.B. (2001). "Thermal Modeling of the Metal Cutting Process"
 *
 * @module algorithms/JaegerTempField
 */

import type {
  Algorithm, AlgorithmMeta, ValidationResult, ValidationIssue, WithWarnings,
} from "./types.js";

export interface JaegerTempFieldInput {
  /** Total heat flux into workpiece [W/mm²]. */
  heat_flux: number;
  /** Contact half-width (half of tool-workpiece contact) [mm]. */
  contact_half_width: number;
  /** Cutting speed (heat source velocity) [m/min]. */
  cutting_speed: number;
  /** Workpiece thermal conductivity [W/(m·K)]. Default 50 (steel). */
  thermal_conductivity?: number;
  /** Workpiece thermal diffusivity [mm²/s]. Default 14 (steel). */
  thermal_diffusivity?: number;
  /** Ambient temperature [°C]. Default 20. */
  ambient_temp?: number;
  /** Heat partition fraction going into workpiece. Default 0.5. */
  partition_ratio?: number;
  /** Grid resolution for field computation. Default 20. */
  grid_resolution?: number;
  /** Depth range for subsurface profile [mm]. Default 2. */
  depth_range?: number;
}

export interface TempFieldPoint {
  x: number;
  z: number;
  temperature: number;
}

export interface JaegerTempFieldOutput extends WithWarnings {
  /** Maximum surface temperature [°C]. */
  max_surface_temp: number;
  /** Temperature at trailing edge of contact [°C]. */
  trailing_edge_temp: number;
  /** Temperature at leading edge of contact [°C]. */
  leading_edge_temp: number;
  /** Peclet number (ratio of convective to conductive heat transfer). */
  peclet_number: number;
  /** Subsurface temperature profile at x=0 (center of heat source). */
  depth_profile: Array<{ depth: number; temperature: number }>;
  /** Full 2D temperature field (x-z plane). */
  temperature_field: TempFieldPoint[];
  /** Depth at which temperature drops to 50% of max [mm]. */
  half_temp_depth: number;
  /** Whether burn risk exists (max temp > material-dependent threshold). */
  burn_risk: boolean;
  /** Estimated affected depth where T > 200°C [mm]. */
  heat_affected_depth: number;
  calculation_method: string;
}

export class JaegerTempField implements Algorithm<JaegerTempFieldInput, JaegerTempFieldOutput> {

  validate(input: JaegerTempFieldInput): ValidationResult {
    const issues: ValidationIssue[] = [];
    if (!input.heat_flux || input.heat_flux <= 0) {
      issues.push({ field: "heat_flux", message: "Must be > 0", severity: "error" });
    }
    if (!input.contact_half_width || input.contact_half_width <= 0) {
      issues.push({ field: "contact_half_width", message: "Must be > 0", severity: "error" });
    }
    if (!input.cutting_speed || input.cutting_speed <= 0) {
      issues.push({ field: "cutting_speed", message: "Must be > 0", severity: "error" });
    }
    if ((input.thermal_conductivity ?? 50) <= 0) {
      issues.push({ field: "thermal_conductivity", message: "Must be > 0", severity: "error" });
    }
    if ((input.thermal_diffusivity ?? 14) <= 0) {
      issues.push({ field: "thermal_diffusivity", message: "Must be > 0", severity: "error" });
    }
    if (input.heat_flux > 500) {
      issues.push({ field: "heat_flux", message: "Very high heat flux — verify input", severity: "warning" });
    }
    return { valid: issues.filter(i => i.severity === "error").length === 0, issues };
  }

  calculate(input: JaegerTempFieldInput): JaegerTempFieldOutput {
    const warnings: string[] = [];
    const q = input.heat_flux * (input.partition_ratio ?? 0.5); // W/mm² into workpiece
    const a = input.contact_half_width; // mm
    const V = input.cutting_speed * 1000 / 60; // m/min → mm/s
    const k = (input.thermal_conductivity ?? 50) / 1000; // W/(m·K) → W/(mm·K)
    const alpha = input.thermal_diffusivity ?? 14; // mm²/s
    const T0 = input.ambient_temp ?? 20;
    const nGrid = input.grid_resolution ?? 20;
    const depthRange = input.depth_range ?? 2;

    // Peclet number: L = V·a / (2·α)
    const Pe = (V * a) / (2 * alpha);

    // Maximum surface temperature (Jaeger's solution for band source)
    // T_max ≈ (q·a)/(k) × f(Pe) where f(Pe) depends on regime
    // For high Pe (most machining): T_max ≈ 1.1284 × (q/k) × sqrt(α·a/V)
    // For low Pe: T_max ≈ (q·a/k) × (1 + 0.307/Pe + ...)
    let Tmax: number;
    if (Pe > 5) {
      // High-speed regime
      Tmax = 1.1284 * (q / k) * Math.sqrt(alpha * a / V);
    } else if (Pe > 0.1) {
      // Intermediate regime — numerical integration
      Tmax = this.surfaceTemp(0, 0, q, a, V, k, alpha);
    } else {
      // Quasi-static regime
      Tmax = (q * a / k) * (1 + 0.307 / Math.max(Pe, 0.01));
    }

    // Surface temperature along contact zone
    const trailingEdge = this.surfaceTemp(-a, 0, q, a, V, k, alpha);
    const leadingEdge = this.surfaceTemp(a, 0, q, a, V, k, alpha);

    // Depth profile at x=0
    const depthProfile: Array<{ depth: number; temperature: number }> = [];
    for (let i = 0; i <= nGrid; i++) {
      const z = (i / nGrid) * depthRange;
      const T = this.surfaceTemp(0, z, q, a, V, k, alpha);
      depthProfile.push({ depth: z, temperature: T + T0 });
    }

    // Half-temperature depth
    let halfTempDepth = 0;
    for (const dp of depthProfile) {
      if (dp.temperature - T0 < Tmax / 2) {
        halfTempDepth = dp.depth;
        break;
      }
    }

    // Heat-affected depth (T > 200°C)
    let hadDepth = 0;
    for (const dp of depthProfile) {
      if (dp.temperature > 200) hadDepth = dp.depth;
    }

    // 2D temperature field
    const tempField: TempFieldPoint[] = [];
    for (let ix = -nGrid; ix <= nGrid; ix++) {
      const x = (ix / nGrid) * 2 * a;
      for (let iz = 0; iz <= nGrid / 2; iz++) {
        const z = (iz / (nGrid / 2)) * depthRange;
        const T = this.surfaceTemp(x, z, q, a, V, k, alpha) + T0;
        tempField.push({ x, z, temperature: T });
      }
    }

    const maxSurfaceTemp = Tmax + T0;
    const burnRisk = maxSurfaceTemp > 600; // Approximate for steel

    if (burnRisk) {
      warnings.push(`BURN RISK: max surface temperature ${maxSurfaceTemp.toFixed(0)}°C exceeds 600°C threshold`);
    }
    if (Pe > 50) {
      warnings.push("Very high Peclet number — predominantly convective heat transfer");
    }

    return {
      max_surface_temp: maxSurfaceTemp,
      trailing_edge_temp: trailingEdge + T0,
      leading_edge_temp: leadingEdge + T0,
      peclet_number: Pe,
      depth_profile: depthProfile,
      temperature_field: tempField,
      half_temp_depth: halfTempDepth,
      burn_risk: burnRisk,
      heat_affected_depth: hadDepth,
      warnings,
      calculation_method: `Jaeger band source (Pe=${Pe.toFixed(2)}, a=${a}mm, V=${V.toFixed(1)}mm/s)`,
    };
  }

  /**
   * Jaeger's solution for temperature at (x, z) due to a moving band source.
   * Uses numerical integration over the contact zone [-a, a].
   * T(x,z) = (q/(2πk)) ∫_{-a}^{a} exp(-V(x-x')/(2α)) × K0(V·r/(2α)) dx'
   * where r = sqrt((x-x')² + z²) and K0 is modified Bessel function of 2nd kind.
   *
   * Simplified approximation using exponential decay for subsurface.
   */
  private surfaceTemp(x: number, z: number, q: number, a: number, V: number, k: number, alpha: number): number {
    const nSteps = 40;
    const dx = (2 * a) / nSteps;
    let T = 0;

    for (let i = 0; i <= nSteps; i++) {
      const xPrime = -a + i * dx;
      const xi = x - xPrime;
      const r = Math.sqrt(xi * xi + z * z);
      if (r < 1e-10) {
        // Singularity at r=0 — use limiting form
        T += (q / (2 * Math.PI * k)) * dx * (Math.log(2 * alpha / (V * 1e-10)) + 0.5772);
        continue;
      }

      const arg = V * r / (2 * alpha);
      // K0 approximation: K0(x) ≈ -ln(x/2) - 0.5772 for small x
      //                    K0(x) ≈ sqrt(π/(2x)) × exp(-x) for large x
      let K0: number;
      if (arg < 2) {
        const t = arg / 2;
        K0 = -Math.log(t) - 0.5772 + t * t * (0.4228 + t * t * (0.2307 + t * t * 0.0348));
      } else {
        K0 = Math.sqrt(Math.PI / (2 * arg)) * Math.exp(-arg);
      }

      const exponential = Math.exp(-V * xi / (2 * alpha));
      T += (q / (2 * Math.PI * k)) * exponential * K0 * dx;
    }

    return Math.max(0, T);
  }

  getMetadata(): AlgorithmMeta {
    return {
      id: "jaeger-temp-field",
      name: "Jaeger Temperature Field",
      description: "Moving band heat source analytical solution for machining temperature prediction",
      formula: "T(x,z) = (q/2πk) ∫ exp(-V(x-x')/(2α)) × K₀(Vr/(2α)) dx'",
      reference: "Jaeger (1942); Carslaw & Jaeger (1959); Komanduri & Hou (2001)",
      safety_class: "critical",
      domain: "thermal",
      inputs: { heat_flux: "Heat source intensity [W/mm²]", cutting_speed: "Source velocity [m/min]", contact_half_width: "Contact zone half-width [mm]" },
      outputs: { max_surface_temp: "Peak temperature [°C]", burn_risk: "Whether thermal damage is likely", depth_profile: "Subsurface temperature distribution" },
    };
  }
}
