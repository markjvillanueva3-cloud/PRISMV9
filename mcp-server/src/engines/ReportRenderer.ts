/**
 * ReportRenderer.ts — Pure Template Rendering Engine for Manufacturing Reports
 * =============================================================================
 *
 * PURPOSE: Render structured manufacturing data into formatted markdown reports
 * suitable for shop floor use. Zero async, zero registry dependencies.
 *
 * REPORT TYPES:
 *   1. setup_sheet     — Machine setup sheet with tool list and operation tables
 *   2. process_plan    — Manufacturing process plan with step sequence
 *   3. cost_estimate   — Cost breakdown with per-part and batch totals
 *   4. tool_list       — Tool BOM formatted for shop floor
 *   5. inspection_plan — Quality inspection plan with critical feature highlighting
 *   6. alarm_report    — Alarm diagnosis with severity badge and remediation steps
 *   7. speed_feed_card — Compact speed/feed reference card
 *
 * @version 1.0.0
 * @date 2026-02-21
 */

// ─── Public Types ─────────────────────────────────────────────────────────────

export type ReportType =
  | "setup_sheet"
  | "process_plan"
  | "cost_estimate"
  | "tool_list"
  | "inspection_plan"
  | "alarm_report"
  | "speed_feed_card";

export interface ReportResult {
  type: ReportType;
  markdown: string;
  line_count: number;
  sections: string[];
  warnings: string[];
}

export const REPORT_TYPES: ReportType[] = [
  "setup_sheet",
  "process_plan",
  "cost_estimate",
  "tool_list",
  "inspection_plan",
  "alarm_report",
  "speed_feed_card",
];

// ─── Internal Helpers ─────────────────────────────────────────────────────────

const FOOTER = "\n\n---\n*Generated by PRISM ReportRenderer v1.0*";

/** Throw a validation error with consistent prefix. */
function fail(msg: string): never {
  throw new Error(`[ReportRenderer] ${msg}`);
}

/** Return value or "N/A" string for optional fields. */
function na(value: string | number | undefined | null): string {
  if (value === undefined || value === null || value === "") return "N/A";
  return String(value);
}

/** Format a number with fixed decimal places; return "N/A" if undefined. */
function fmt(value: number | undefined, decimals = 2): string {
  if (value === undefined || value === null) return "N/A";
  return value.toFixed(decimals);
}

/** Format a currency value to 2 decimal places with $ prefix. */
function fmtCost(value: number | undefined): string {
  if (value === undefined || value === null) return "N/A";
  return `$${value.toFixed(2)}`;
}

/** Extract section headings (## lines) from rendered markdown. */
function extractSections(markdown: string): string[] {
  return markdown
    .split("\n")
    .filter((line) => /^#{1,3} /.test(line))
    .map((line) => line.replace(/^#{1,3} /, "").trim());
}

/** Build a markdown table from headers and rows. */
function table(headers: string[], rows: string[][]): string {
  const sep = headers.map(() => "---");
  const head = `| ${headers.join(" | ")} |`;
  const divider = `| ${sep.join(" | ")} |`;
  const body = rows
    .map((row) => `| ${row.map((c) => c ?? "N/A").join(" | ")} |`)
    .join("\n");
  return [head, divider, body].join("\n");
}

// ─── 1. Setup Sheet ───────────────────────────────────────────────────────────

interface SetupPhase {
  type: string;
  cutting_speed: number;
  feed_per_tooth: number;
  axial_depth: number;
  radial_depth: number;
  spindle_speed: number;
  feed_rate: number;
}

interface SetupOperation {
  sequence: number;
  feature: string;
  phases: SetupPhase[];
  coolant?: { strategy: string; pressure_bar?: number };
  cycle_time_min?: number;
}

interface SetupTool {
  sequence: number;
  type: string;
  diameter_mm: number;
  flutes?: number;
  coating?: string;
  holder?: string;
  stickout_mm?: number;
}

interface SetupSheetData {
  part_name: string;
  part_number?: string;
  material: string;
  iso_group?: string;
  machine?: string;
  date?: string;
  operator?: string;
  tools: SetupTool[];
  operations: SetupOperation[];
  safety_notes?: string[];
  total_cycle_time_min?: number;
  work_offset?: string;
  fixture?: string;
  notes?: string;
}

function renderSetupSheet(data: Record<string, any>): string {
  if (!data.part_name) fail("setup_sheet requires 'part_name'");
  if (!data.material) fail("setup_sheet requires 'material'");
  if (!Array.isArray(data.tools)) fail("setup_sheet requires 'tools' array");
  if (!Array.isArray(data.operations)) fail("setup_sheet requires 'operations' array");

  const d = data as SetupSheetData;
  const lines: string[] = [];

  // Header block
  lines.push("# MACHINE SETUP SHEET");
  lines.push("");
  lines.push("## Job Information");
  lines.push("");
  lines.push(`| Field | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| **Part Name** | ${d.part_name} |`);
  lines.push(`| **Part Number** | ${na(d.part_number)} |`);
  lines.push(`| **Material** | ${d.material} |`);
  lines.push(`| **ISO Group** | ${na(d.iso_group)} |`);
  lines.push(`| **Machine** | ${na(d.machine)} |`);
  lines.push(`| **Work Offset** | ${na(d.work_offset)} |`);
  lines.push(`| **Fixture** | ${na(d.fixture)} |`);
  lines.push(`| **Date** | ${na(d.date)} |`);
  lines.push(`| **Operator** | ${na(d.operator)} |`);

  // Tool list
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Tool List");
  lines.push("");

  const toolHeaders = ["Seq", "Type", "Ø (mm)", "Flutes", "Coating", "Holder", "Stickout (mm)"];
  const toolRows = d.tools.map((t) => [
    String(t.sequence),
    t.type,
    fmt(t.diameter_mm, 1),
    na(t.flutes),
    na(t.coating),
    na(t.holder),
    na(t.stickout_mm),
  ]);
  lines.push(table(toolHeaders, toolRows));

  // Operations
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Operations");

  for (const op of d.operations) {
    lines.push("");
    lines.push(`### Op ${op.sequence}: ${op.feature}`);
    lines.push("");

    // Phases table
    const phaseHeaders = ["Phase", "Vc (m/min)", "fz (mm)", "ap (mm)", "ae (mm)", "n (rpm)", "Vf (mm/min)"];
    const phaseRows = (op.phases || []).map((ph) => [
      ph.type,
      fmt(ph.cutting_speed, 0),
      fmt(ph.feed_per_tooth, 3),
      fmt(ph.axial_depth, 2),
      fmt(ph.radial_depth, 2),
      fmt(ph.spindle_speed, 0),
      fmt(ph.feed_rate, 0),
    ]);
    if (phaseRows.length > 0) {
      lines.push(table(phaseHeaders, phaseRows));
    } else {
      lines.push("*No phase data provided.*");
    }

    // Coolant
    if (op.coolant) {
      const pressureStr =
        op.coolant.pressure_bar !== undefined
          ? ` @ ${op.coolant.pressure_bar} bar`
          : "";
      lines.push("");
      lines.push(`**Coolant:** ${op.coolant.strategy}${pressureStr}`);
    }

    // Cycle time
    if (op.cycle_time_min !== undefined) {
      lines.push("");
      lines.push(`**Cycle Time:** ${fmt(op.cycle_time_min, 1)} min`);
    }
  }

  // Cycle time summary
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Cycle Time Summary");
  lines.push("");

  const opTimes = d.operations
    .filter((op) => op.cycle_time_min !== undefined)
    .map((op) => [`Op ${op.sequence}: ${op.feature}`, `${fmt(op.cycle_time_min, 1)} min`]);

  if (opTimes.length > 0) {
    lines.push(table(["Operation", "Time"], opTimes));
    lines.push("");
  }

  const totalTime =
    d.total_cycle_time_min !== undefined
      ? fmt(d.total_cycle_time_min, 1)
      : d.operations.reduce((sum, op) => sum + (op.cycle_time_min ?? 0), 0).toFixed(1);
  lines.push(`**Total Cycle Time: ${totalTime} min**`);

  // Safety notes
  if (d.safety_notes && d.safety_notes.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Safety Notes");
    lines.push("");
    for (const note of d.safety_notes) {
      lines.push(`- ${note}`);
    }
  }

  // General notes
  if (d.notes) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Notes");
    lines.push("");
    lines.push(d.notes);
  }

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 2. Process Plan ─────────────────────────────────────────────────────────

interface ProcessOperation {
  step: number;
  description: string;
  machine?: string;
  tools_required?: string[];
  parameters?: Record<string, string | number>;
  quality_checks?: string[];
  estimated_time_min?: number;
}

interface ProcessPlanData {
  part_name: string;
  part_number?: string;
  material: string;
  operations: ProcessOperation[];
  total_time_min?: number;
  revision?: string;
  approved_by?: string;
}

function renderProcessPlan(data: Record<string, any>): string {
  if (!data.part_name) fail("process_plan requires 'part_name'");
  if (!data.material) fail("process_plan requires 'material'");
  if (!Array.isArray(data.operations)) fail("process_plan requires 'operations' array");

  const d = data as ProcessPlanData;
  const lines: string[] = [];

  lines.push("# MANUFACTURING PROCESS PLAN");
  lines.push("");
  lines.push("## Document Information");
  lines.push("");
  lines.push(`| Field | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| **Part Name** | ${d.part_name} |`);
  lines.push(`| **Part Number** | ${na(d.part_number)} |`);
  lines.push(`| **Material** | ${d.material} |`);
  lines.push(`| **Revision** | ${na(d.revision)} |`);
  lines.push(`| **Approved By** | ${na(d.approved_by)} |`);

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Operation Sequence");

  for (const op of d.operations) {
    lines.push("");
    lines.push(`### Step ${op.step}: ${op.description}`);
    lines.push("");

    const metaRows: string[][] = [];
    if (op.machine) metaRows.push(["Machine", op.machine]);
    if (op.estimated_time_min !== undefined)
      metaRows.push(["Est. Time", `${fmt(op.estimated_time_min, 1)} min`]);

    if (metaRows.length > 0) {
      lines.push(table(["Field", "Value"], metaRows));
      lines.push("");
    }

    if (op.tools_required && op.tools_required.length > 0) {
      lines.push("**Tools Required:**");
      for (const tool of op.tools_required) {
        lines.push(`- ${tool}`);
      }
      lines.push("");
    }

    if (op.parameters && Object.keys(op.parameters).length > 0) {
      lines.push("**Parameters:**");
      const paramRows = Object.entries(op.parameters).map(([k, v]) => [k, String(v)]);
      lines.push(table(["Parameter", "Value"], paramRows));
      lines.push("");
    }

    if (op.quality_checks && op.quality_checks.length > 0) {
      lines.push("**Quality Checks:**");
      for (const check of op.quality_checks) {
        lines.push(`- [ ] ${check}`);
      }
    }
  }

  // Time summary
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Time Summary");
  lines.push("");

  const stepTimes = d.operations
    .filter((op) => op.estimated_time_min !== undefined)
    .map((op) => [`Step ${op.step}: ${op.description}`, `${fmt(op.estimated_time_min, 1)} min`]);

  if (stepTimes.length > 0) {
    lines.push(table(["Step", "Est. Time"], stepTimes));
    lines.push("");
  }

  const total =
    d.total_time_min !== undefined
      ? fmt(d.total_time_min, 1)
      : d.operations.reduce((s, op) => s + (op.estimated_time_min ?? 0), 0).toFixed(1);
  lines.push(`**Total Estimated Time: ${total} min**`);

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 3. Cost Estimate ─────────────────────────────────────────────────────────

interface CostBreakdownItem {
  item: string;
  cost: number;
  note?: string;
}

interface CostEstimateData {
  part_name: string;
  quantity: number;
  material_cost?: number;
  machine_cost_per_hour?: number;
  cycle_time_min?: number;
  setup_time_min?: number;
  tool_cost_per_part?: number;
  labor_cost_per_hour?: number;
  overhead_percent?: number;
  breakdown?: CostBreakdownItem[];
}

function renderCostEstimate(data: Record<string, any>): string {
  if (!data.part_name) fail("cost_estimate requires 'part_name'");
  if (data.quantity === undefined || data.quantity === null)
    fail("cost_estimate requires 'quantity'");

  const d = data as CostEstimateData;
  const warnings: string[] = [];

  if (d.quantity <= 0) warnings.push("Quantity is zero or negative — totals may be invalid.");

  const lines: string[] = [];
  lines.push("# MANUFACTURING COST ESTIMATE");
  lines.push("");
  lines.push("## Job Information");
  lines.push("");
  lines.push(`| Field | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| **Part Name** | ${d.part_name} |`);
  lines.push(`| **Quantity** | ${d.quantity} pc |`);

  // Compute costs
  const cycleMachineHrs = (d.cycle_time_min ?? 0) / 60;
  const setupMachineHrs = (d.setup_time_min ?? 0) / 60;

  const machineCycleCost =
    d.machine_cost_per_hour !== undefined
      ? d.machine_cost_per_hour * cycleMachineHrs
      : undefined;

  const machineSetupCost =
    d.machine_cost_per_hour !== undefined && d.setup_time_min !== undefined
      ? d.machine_cost_per_hour * setupMachineHrs
      : undefined;

  const laborCycleCost =
    d.labor_cost_per_hour !== undefined
      ? d.labor_cost_per_hour * cycleMachineHrs
      : undefined;

  // Build per-part cost table
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Per-Part Cost Breakdown");
  lines.push("");

  interface CostRow {
    label: string;
    perPart: number | undefined;
    note: string;
  }

  const costRows: CostRow[] = [];

  if (d.material_cost !== undefined)
    costRows.push({ label: "Material", perPart: d.material_cost, note: "" });

  if (machineCycleCost !== undefined)
    costRows.push({
      label: "Machine Time",
      perPart: machineCycleCost,
      note: `${fmt(d.cycle_time_min, 1)} min @ ${fmtCost(d.machine_cost_per_hour)}/hr`,
    });

  if (laborCycleCost !== undefined)
    costRows.push({
      label: "Labor",
      perPart: laborCycleCost,
      note: `${fmt(d.cycle_time_min, 1)} min @ ${fmtCost(d.labor_cost_per_hour)}/hr`,
    });

  if (d.tool_cost_per_part !== undefined)
    costRows.push({ label: "Tooling", perPart: d.tool_cost_per_part, note: "amortized" });

  // Custom breakdown items
  if (d.breakdown && d.breakdown.length > 0) {
    for (const item of d.breakdown) {
      costRows.push({ label: item.item, perPart: item.cost, note: item.note ?? "" });
    }
  }

  const subtotalPerPart = costRows.reduce((s, r) => s + (r.perPart ?? 0), 0);

  const overheadPerPart =
    d.overhead_percent !== undefined
      ? subtotalPerPart * (d.overhead_percent / 100)
      : undefined;

  const totalPerPart = subtotalPerPart + (overheadPerPart ?? 0);

  const tableHeaders = ["Cost Element", "Per Part", "Note"];
  const tableRows = costRows.map((r) => [r.label, fmtCost(r.perPart), r.note || "—"]);

  if (overheadPerPart !== undefined) {
    tableRows.push(["Overhead", fmtCost(overheadPerPart), `${d.overhead_percent}% of subtotal`]);
  }

  if (tableRows.length > 0) {
    lines.push(table(tableHeaders, tableRows));
  } else {
    lines.push("*No cost data provided.*");
  }

  lines.push("");
  lines.push(`**Per-Part Total: ${fmtCost(totalPerPart)}**`);

  // Setup cost (one-time)
  if (machineSetupCost !== undefined || d.setup_time_min !== undefined) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Setup Cost (One-Time)");
    lines.push("");
    const setupRows: string[][] = [];
    if (d.setup_time_min !== undefined)
      setupRows.push(["Setup Time", `${fmt(d.setup_time_min, 1)} min`, ""]);
    if (machineSetupCost !== undefined)
      setupRows.push([
        "Setup Machine Cost",
        fmtCost(machineSetupCost),
        `@ ${fmtCost(d.machine_cost_per_hour)}/hr`,
      ]);
    lines.push(table(["Item", "Cost", "Note"], setupRows));
  }

  // Batch totals
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Batch Totals");
  lines.push("");

  const batchCycleTotal = totalPerPart * d.quantity;
  const setupAmortized = machineSetupCost !== undefined ? machineSetupCost / d.quantity : 0;
  const totalPerPartWithSetup = totalPerPart + setupAmortized;
  const batchTotal = batchCycleTotal + (machineSetupCost ?? 0);

  const batchRows = [
    ["Quantity", `${d.quantity} pc`, ""],
    ["Cycle Cost (total)", fmtCost(batchCycleTotal), ""],
    ["Setup Cost", fmtCost(machineSetupCost), "one-time"],
    ["Setup Amortized / Part", fmtCost(setupAmortized > 0 ? setupAmortized : undefined), ""],
    ["**Total Batch Cost**", `**${fmtCost(batchTotal)}**`, ""],
    ["**Total Per Part (incl. setup)**", `**${fmtCost(totalPerPartWithSetup)}**`, ""],
  ];

  lines.push(table(["Item", "Value", "Note"], batchRows));

  if (warnings.length > 0) {
    lines.push("");
    lines.push("> **Warnings:** " + warnings.join("; "));
  }

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 4. Tool List ─────────────────────────────────────────────────────────────

interface ToolListEntry {
  position: number;
  description: string;
  type: string;
  diameter_mm?: number;
  manufacturer?: string;
  catalog_number?: string;
  coating?: string;
  grade?: string;
  quantity?: number;
  notes?: string;
}

interface ToolListData {
  part_name?: string;
  tools: ToolListEntry[];
}

function renderToolList(data: Record<string, any>): string {
  if (!Array.isArray(data.tools)) fail("tool_list requires 'tools' array");

  const d = data as ToolListData;
  const lines: string[] = [];

  lines.push("# TOOL LIST");
  if (d.part_name) {
    lines.push("");
    lines.push(`**Part:** ${d.part_name}`);
  }
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Tool Register");
  lines.push("");

  const headers = ["Pos", "Description", "Type", "Ø (mm)", "Mfr", "Catalog #", "Coating", "Grade", "Qty", "Notes"];
  const rows = d.tools.map((t) => [
    String(t.position),
    t.description,
    t.type,
    t.diameter_mm !== undefined ? fmt(t.diameter_mm, 1) : "N/A",
    na(t.manufacturer),
    na(t.catalog_number),
    na(t.coating),
    na(t.grade),
    t.quantity !== undefined ? String(t.quantity) : "1",
    na(t.notes),
  ]);

  lines.push(table(headers, rows));
  lines.push("");
  lines.push(`**Total Tools: ${d.tools.length}**`);

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 5. Inspection Plan ───────────────────────────────────────────────────────

interface InspectionFeature {
  feature_id: string;
  description: string;
  nominal: number;
  tolerance: string;
  measurement_method?: string;
  frequency?: string;
  critical?: boolean;
}

interface InspectionPlanData {
  part_name: string;
  part_number?: string;
  material?: string;
  features: InspectionFeature[];
  general_tolerances?: string;
  surface_finish_spec?: string;
  notes?: string[];
}

function renderInspectionPlan(data: Record<string, any>): string {
  if (!data.part_name) fail("inspection_plan requires 'part_name'");
  if (!Array.isArray(data.features)) fail("inspection_plan requires 'features' array");

  const d = data as InspectionPlanData;
  const warnings: string[] = [];

  if (d.features.length === 0) warnings.push("Inspection plan has no features defined.");

  const lines: string[] = [];

  lines.push("# QUALITY INSPECTION PLAN");
  lines.push("");
  lines.push("## Part Information");
  lines.push("");
  lines.push(`| Field | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| **Part Name** | ${d.part_name} |`);
  lines.push(`| **Part Number** | ${na(d.part_number)} |`);
  lines.push(`| **Material** | ${na(d.material)} |`);
  lines.push(`| **General Tolerances** | ${na(d.general_tolerances)} |`);
  lines.push(`| **Surface Finish** | ${na(d.surface_finish_spec)} |`);

  const criticalCount = d.features.filter((f) => f.critical).length;
  lines.push(`| **Critical Features** | ${criticalCount} |`);

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Inspection Features");
  lines.push("");

  const headers = ["ID", "Description", "Nominal", "Tolerance", "Method", "Frequency", "Critical"];
  const rows = d.features.map((f) => [
    f.feature_id,
    f.critical ? `**${f.description}**` : f.description,
    fmt(f.nominal, 3),
    f.tolerance,
    na(f.measurement_method),
    na(f.frequency),
    f.critical ? "**YES**" : "no",
  ]);

  lines.push(table(headers, rows));

  // Critical features summary
  const criticals = d.features.filter((f) => f.critical);
  if (criticals.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Critical Features Summary");
    lines.push("");
    lines.push("> **WARNING: The following features are safety/function critical.**");
    lines.push("> Verify 100% before releasing to next operation.");
    lines.push("");
    for (const f of criticals) {
      lines.push(`- **${f.feature_id}** — ${f.description}: ${fmt(f.nominal, 3)} ${f.tolerance}`);
    }
  }

  if (d.notes && d.notes.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Notes");
    lines.push("");
    for (const note of d.notes) {
      lines.push(`- ${note}`);
    }
  }

  if (warnings.length > 0) {
    lines.push("");
    lines.push("> **Warnings:** " + warnings.join("; "));
  }

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 6. Alarm Report ──────────────────────────────────────────────────────────

interface AlarmReportData {
  alarm_code: string;
  alarm_name?: string;
  machine?: string;
  severity?: string;
  description?: string;
  probable_causes?: string[];
  remediation_steps?: string[];
  prevention_tips?: string[];
  related_codes?: string[];
  timestamp?: string;
}

function renderAlarmReport(data: Record<string, any>): string {
  if (!data.alarm_code) fail("alarm_report requires 'alarm_code'");

  const d = data as AlarmReportData;
  const lines: string[] = [];

  // Severity badge
  const severityMap: Record<string, string> = {
    critical: "CRITICAL",
    high: "HIGH",
    medium: "MEDIUM",
    low: "LOW",
    warning: "WARNING",
    info: "INFO",
  };
  const severityKey = (d.severity ?? "").toLowerCase();
  const severityBadge = severityMap[severityKey] ?? (d.severity ? d.severity.toUpperCase() : "UNKNOWN");

  lines.push("# ALARM DIAGNOSIS REPORT");
  lines.push("");
  lines.push(`> **Severity: ${severityBadge}**`);
  lines.push("");
  lines.push("## Alarm Information");
  lines.push("");
  lines.push(`| Field | Value |`);
  lines.push(`| --- | --- |`);
  lines.push(`| **Alarm Code** | ${d.alarm_code} |`);
  lines.push(`| **Alarm Name** | ${na(d.alarm_name)} |`);
  lines.push(`| **Machine** | ${na(d.machine)} |`);
  lines.push(`| **Severity** | ${severityBadge} |`);
  lines.push(`| **Timestamp** | ${na(d.timestamp)} |`);

  if (d.description) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Description");
    lines.push("");
    lines.push(d.description);
  }

  if (d.probable_causes && d.probable_causes.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Probable Causes");
    lines.push("");
    d.probable_causes.forEach((cause, i) => {
      lines.push(`${i + 1}. ${cause}`);
    });
  }

  if (d.remediation_steps && d.remediation_steps.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Remediation Steps");
    lines.push("");
    d.remediation_steps.forEach((step, i) => {
      lines.push(`${i + 1}. ${step}`);
    });
  }

  if (d.prevention_tips && d.prevention_tips.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Prevention");
    lines.push("");
    for (const tip of d.prevention_tips) {
      lines.push(`- ${tip}`);
    }
  }

  if (d.related_codes && d.related_codes.length > 0) {
    lines.push("");
    lines.push("---");
    lines.push("");
    lines.push("## Related Alarm Codes");
    lines.push("");
    lines.push(d.related_codes.join(", "));
  }

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── 7. Speed/Feed Card ───────────────────────────────────────────────────────

interface SpeedFeedOperation {
  operation: string;
  tool_diameter_mm?: number;
  cutting_speed_m_min: number;
  feed_per_tooth_mm: number;
  axial_depth_mm: number;
  radial_depth_mm: number;
  spindle_speed_rpm: number;
  feed_rate_mm_min: number;
  coolant?: string;
  notes?: string;
}

interface SpeedFeedCardData {
  material: string;
  iso_group?: string;
  tool_type?: string;
  operations: SpeedFeedOperation[];
}

function renderSpeedFeedCard(data: Record<string, any>): string {
  if (!data.material) fail("speed_feed_card requires 'material'");
  if (!Array.isArray(data.operations)) fail("speed_feed_card requires 'operations' array");

  const d = data as SpeedFeedCardData;
  const lines: string[] = [];

  lines.push("# SPEED / FEED REFERENCE CARD");
  lines.push("");
  lines.push(`**Material:** ${d.material}`);
  if (d.iso_group) lines.push(`**ISO Group:** ${d.iso_group}`);
  if (d.tool_type) lines.push(`**Tool Type:** ${d.tool_type}`);

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## Cutting Parameters");
  lines.push("");

  const headers = [
    "Operation",
    "Ø (mm)",
    "Vc (m/min)",
    "fz (mm)",
    "ap (mm)",
    "ae (mm)",
    "n (rpm)",
    "Vf (mm/min)",
    "Coolant",
    "Notes",
  ];

  const rows = d.operations.map((op) => [
    op.operation,
    op.tool_diameter_mm !== undefined ? fmt(op.tool_diameter_mm, 1) : "N/A",
    fmt(op.cutting_speed_m_min, 0),
    fmt(op.feed_per_tooth_mm, 3),
    fmt(op.axial_depth_mm, 2),
    fmt(op.radial_depth_mm, 2),
    fmt(op.spindle_speed_rpm, 0),
    fmt(op.feed_rate_mm_min, 0),
    na(op.coolant),
    na(op.notes),
  ]);

  lines.push(table(headers, rows));

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("### Legend");
  lines.push("");
  lines.push("| Symbol | Meaning |");
  lines.push("| --- | --- |");
  lines.push("| Vc | Cutting speed (m/min) |");
  lines.push("| fz | Feed per tooth (mm) |");
  lines.push("| ap | Axial depth of cut (mm) |");
  lines.push("| ae | Radial depth of cut (mm) |");
  lines.push("| n  | Spindle speed (rpm) |");
  lines.push("| Vf | Table feed rate (mm/min) |");

  lines.push(FOOTER);
  return lines.join("\n");
}

// ─── Dispatcher Map ───────────────────────────────────────────────────────────

type RendererFn = (data: Record<string, any>) => string;

const RENDERERS: Record<ReportType, RendererFn> = {
  setup_sheet: renderSetupSheet,
  process_plan: renderProcessPlan,
  cost_estimate: renderCostEstimate,
  tool_list: renderToolList,
  inspection_plan: renderInspectionPlan,
  alarm_report: renderAlarmReport,
  speed_feed_card: renderSpeedFeedCard,
};

// ─── Warning Collectors ───────────────────────────────────────────────────────

/**
 * Post-render warning analysis. Checks for suspicious data patterns
 * and returns any warning strings.
 */
function collectWarnings(type: ReportType, data: Record<string, any>): string[] {
  const w: string[] = [];

  if (type === "cost_estimate") {
    const qty = data.quantity as number;
    if (qty !== undefined && qty <= 0) w.push("Quantity is zero or negative.");
    const allCostFields = [
      "material_cost",
      "machine_cost_per_hour",
      "cycle_time_min",
      "tool_cost_per_part",
      "labor_cost_per_hour",
    ];
    const anyDefined = allCostFields.some((f) => data[f] !== undefined);
    if (!anyDefined && (!data.breakdown || data.breakdown.length === 0)) {
      w.push("No cost data fields provided — estimate will show $0.");
    }
  }

  if (type === "inspection_plan") {
    const features = data.features as any[];
    if (!features || features.length === 0) w.push("No inspection features defined.");
  }

  if (type === "setup_sheet") {
    const tools = data.tools as any[];
    const ops = data.operations as any[];
    if (tools && tools.length === 0) w.push("Tool list is empty.");
    if (ops && ops.length === 0) w.push("No operations defined.");
  }

  if (type === "speed_feed_card") {
    const ops = data.operations as any[];
    if (!ops || ops.length === 0) w.push("No operations in speed/feed card.");
  }

  return w;
}

// ─── Public API ───────────────────────────────────────────────────────────────

/**
 * Render a manufacturing report from structured data.
 *
 * @param type  - One of the 7 supported ReportType values
 * @param data  - Structured input matching the type's schema
 * @returns     ReportResult with rendered markdown and metadata
 * @throws      Error with [ReportRenderer] prefix if required fields are missing
 *              or if an unknown report type is requested
 *
 * @example
 * const result = renderReport("tool_list", {
 *   part_name: "Bracket A",
 *   tools: [{ position: 1, description: "12mm End Mill", type: "end_mill", diameter_mm: 12 }]
 * });
 * console.log(result.markdown);
 */
export function renderReport(type: string, data: Record<string, any>): ReportResult {
  if (!RENDERERS[type as ReportType]) {
    fail(
      `Unknown report type "${type}". Valid types: ${REPORT_TYPES.join(", ")}`
    );
  }

  const reportType = type as ReportType;
  const warnings = collectWarnings(reportType, data);
  const markdown = RENDERERS[reportType](data);
  const lines = markdown.split("\n");
  const sections = extractSections(markdown);

  return {
    type: reportType,
    markdown,
    line_count: lines.length,
    sections,
    warnings,
  };
}

/**
 * List all supported report types with their descriptions and required fields.
 */
export function listReportTypes(): Array<{
  type: ReportType;
  description: string;
  required_fields: string[];
}> {
  return [
    {
      type: "setup_sheet",
      description: "Machine setup sheet with tool list and per-operation cutting parameter tables",
      required_fields: ["part_name", "material", "tools", "operations"],
    },
    {
      type: "process_plan",
      description: "Manufacturing process plan with numbered operation sequence, parameters, and quality checks",
      required_fields: ["part_name", "material", "operations"],
    },
    {
      type: "cost_estimate",
      description: "Cost breakdown with per-part costs, setup amortization, and batch totals",
      required_fields: ["part_name", "quantity"],
    },
    {
      type: "tool_list",
      description: "Tool BOM table formatted for shop floor use with all tool attributes",
      required_fields: ["tools"],
    },
    {
      type: "inspection_plan",
      description: "Quality inspection plan with feature table, tolerances, methods, and critical feature callouts",
      required_fields: ["part_name", "features"],
    },
    {
      type: "alarm_report",
      description: "Alarm diagnosis report with severity badge, probable causes, and step-by-step remediation",
      required_fields: ["alarm_code"],
    },
    {
      type: "speed_feed_card",
      description: "Compact speed/feed reference card with cutting parameter table and legend",
      required_fields: ["material", "operations"],
    },
  ];
}
