{"path":"../../scripts/full_audit.js","total_lines":115,"showing":"0-100","content":"const fs = require('fs');\nconst path = require('path');\nconst SRC = 'C:\\\\PRISM\\\\mcp-server\\\\src';\nconst DISP = path.join(SRC, 'tools', 'dispatchers');\nconst ENGINES = path.join(SRC, 'engines');\nconst bugs = [];\n\n// AUDIT 1: ACTIONS vs switch cases\nconst dispFiles = fs.readdirSync(DISP).filter(f => f.endsWith('.ts'));\nfor (const file of dispFiles) {\n  const c = fs.readFileSync(path.join(DISP, file), 'utf8');\n  const am = c.match(/const\\s+ACTIONS\\s*=\\s*\\[([\\s\\S]*?)\\]\\s*as\\s*const/);\n  if (!am) continue;\n  const actions = (am[1].match(/[\"']([^\"']+)[\"']/g)||[]).map(s=>s.replace(/[\"']/g,''));\n  const cases = [...c.matchAll(/case\\s+[\"']([^\"']+)[\"']\\s*:/g)].map(m=>m[1]);\n  for (const a of actions) { if (!cases.includes(a)) bugs.push({file,sev:'HIGH',cat:'dispatch',bug:`Action '${a}' in ACTIONS but NO case`}); }\n  for (const c2 of cases) { if (!actions.includes(c2)) bugs.push({file,sev:'MED',cat:'dispatch',bug:`Case '${c2}' NOT in ACTIONS (unreachable)`}); }\n}\n\n// AUDIT 2: Missing default\nfor (const file of dispFiles) {\n  const c = fs.readFileSync(path.join(DISP, file), 'utf8');\n  if ((c.includes('switch (action)') || c.includes('switch(action)')) && !c.includes('default:') && !c.includes('default :')) {\n    bugs.push({file,sev:'HIGH',cat:'dispatch',bug:'No default case in action switch'});\n  }\n}\n\n// AUDIT 3: Security\nconst allTs = [];\nfunction findTs(dir) { try { for (const f of fs.readdirSync(dir)) { const fp = path.join(dir, f); if (fs.statSync(fp).isDirectory() && !f.startsWith('.') && f !== 'node_modules' && f !== 'dist') findTs(fp); else if (f.endsWith('.ts')) allTs.push(fp); } } catch {} }\nfindTs(SRC);\nfor (const fp of allTs) {\n  const c = fs.readFileSync(fp, 'utf8'); const file = path.relative(SRC, fp);\n  c.split('\\n').forEach((l, i) => {\n    if (l.includes('eval(') && !l.trim().startsWith('//') && !l.trim().startsWith('*')) bugs.push({file,sev:'CRITICAL',cat:'security',bug:`eval() at line ${i+1}`});\n    if (l.includes('new Function(') && !l.trim().startsWith('//')) bugs.push({file,sev:'CRITICAL',cat:'security',bug:`new Function() at line ${i+1}`});\n  });\n}\n\n// AUDIT 4: Import resolution\nfor (const fp of allTs) {\n  const c = fs.readFileSync(fp, 'utf8'); const file = path.relative(SRC, fp);\n  const imports = [...c.matchAll(/from\\s+[\"'](\\.\\/.+?)[\"']/g)];\n  for (const imp of imports) {\n    let resolved = path.resolve(path.dirname(fp), imp[1].replace(/\\.js$/, '.ts'));\n    if (!fs.existsSync(resolved) && !fs.existsSync(resolved.replace('.ts', '/index.ts'))) bugs.push({file,sev:'HIGH',cat:'import',bug:`Import '${imp[1]}' unresolved`});\n  }\n}\n\n// AUDIT 5: Description counts vs actual\nfor (const file of dispFiles) {\n  const c = fs.readFileSync(path.join(DISP, file), 'utf8');\n  const descMatch = c.match(/(\\d+)\\s*actions/);\n  const am = c.match(/const\\s+ACTIONS\\s*=\\s*\\[([\\s\\S]*?)\\]\\s*as\\s*const/);\n  if (descMatch && am) {\n    const claimed = parseInt(descMatch[1]); const actual = (am[1].match(/[\"']([^\"']+)[\"']/g)||[]).length;\n    if (claimed !== actual) bugs.push({file,sev:'LOW',cat:'docs',bug:`Says ${claimed} actions, has ${actual}`});\n  }\n}\n\n// AUDIT 6: TODO/FIXME/HACK\nfor (const fp of allTs) {\n  const c = fs.readFileSync(fp, 'utf8'); const file = path.relative(SRC, fp);\n  c.split('\\n').forEach((l, i) => {\n    const m = l.match(/\\b(TODO|FIXME|HACK|XXX)\\b/i);\n    if (m) bugs.push({file,sev:'LOW',cat:'debt',bug:`${m[0]} line ${i+1}: ${l.trim().slice(0,100)}`});\n  });\n}\n\n// AUDIT 7: Engine timer cleanup\nconst engFiles = fs.readdirSync(ENGINES).filter(f => f.endsWith('.ts') && f !== 'index.ts');\nfor (const file of engFiles) {\n  const c = fs.readFileSync(path.join(ENGINES, file), 'utf8');\n  const hasTimers = c.includes('setInterval') || c.includes('setTimeout');\n  const hasCleanup = c.includes('clearInterval') || c.includes('clearTimeout') || c.includes('shutdown') || c.includes('destroy');\n  if (hasTimers && !hasCleanup) bugs.push({file,sev:'MED',cat:'engine',bug:'Has timers but no cleanup method'});\n}\n\n// AUDIT 8: Empty catch blocks (count per file)\nlet emptyCatches = {};\nfor (const fp of allTs) {\n  const c = fs.readFileSync(fp, 'utf8'); const file = path.relative(SRC, fp);\n  const m1 = (c.match(/catch\\s*\\{\\s*\\/\\*[^*]*\\*\\/\\s*\\}/g) || []).length;\n  const m2 = (c.match(/catch\\s*\\([^)]*\\)\\s*\\{\\s*\\/\\*[^*]*\\*\\/\\s*\\}/g) || []).length;\n  const m3 = (c.match(/catch\\s*\\{\\s*\\}/g) || []).length;\n  if (m1+m2+m3 > 5) emptyCatches[file] = m1+m2+m3;\n}\n\n// AUDIT 9: any type usage\nlet anyUsage = {};\nfor (const fp of allTs) {\n  const c = fs.readFileSync(fp, 'utf8'); const file = path.relative(SRC, fp);\n  const m = (c.match(/:\\s*any\\b/g) || []).length;\n  if (m > 15) anyUsage[file] = m;\n}\n\n// RESULTS\nconsole.log('\\n=== PRISM FULL SYSTEM AUDIT ===');\nconst bySev = {}; bugs.forEach(b => bySev[b.sev] = (bySev[b.sev]||0) + 1);\nconsole.log('Severity:', JSON.stringify(bySev));"}