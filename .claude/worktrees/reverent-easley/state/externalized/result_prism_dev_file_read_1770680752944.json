{"path":"src/tools/autoHookWrapper.ts","total_lines":1583,"showing":"1-101","content":" * PRISM Auto-Hook Wrapper for TypeScript MCP Server\n * ===================================================\n * \n * PURPOSE: Automatically fire hooks when specific tools execute\n * \n * AUTO-FIRE RULES:\n * - calc_* tools → CALC-BEFORE-EXEC-001, CALC-AFTER-EXEC-001, proof_validate (Λ)\n * - web_search/web_fetch → fact_verify (Φ) on claims detected\n * - prism_sp_* tools → Workflow hooks\n * - Any failure → REFL-002 error analysis\n * \n * @version 1.0.0\n * @date 2026-02-04\n */\n\nimport { z } from 'zod';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { hookExecutor, type HookContext } from '../engines/HookExecutor.js';\nimport { autoTodoRefresh, autoCheckpoint, autoContextPressure, autoCompactionDetect, autoContextCompress, autoErrorLearn, autoPreTaskRecon, autoQualityGate, autoAntiRegression, autoDecisionCapture, autoWarmStartData, autoVariationCheck, autoSkillHint, autoKnowledgeCrossQuery, autoContextPullBack, autoInputValidation, autoScriptRecommend, autoAttentionScore, autoPythonCompactionPredict, autoPythonCompress, autoPythonExpand, autoD3ErrorChain, autoD3LkgUpdate, autoCompactionSurvival, autoContextRehydrate, autoD4CacheCheck, autoD4DiffCheck, autoD4BatchTick, autoD4PerfSummary, autoTelemetrySnapshot } from './cadenceExecutor.js';\nimport { slimCadence, slimJsonResponse, getCurrentPressurePct, getSlimLevel } from '../utils/responseSlimmer.js';\nimport { computationCache } from '../engines/ComputationCache.js';\nimport type { HookResult, ToolCallContext, ProofValidationResult, FactVerifyResult, HookExecution, RecordedAction } from '../types/prism-schema.js';\nimport { telemetryEngine } from '../engines/TelemetryEngine.js';\nimport { pfpEngine } from '../engines/PFPEngine.js';\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst AUTO_HOOK_CONFIG = {\n  enabled: true,\n  \n  // Tools that trigger safety calculation hooks\n  calcTools: [\n    'calc_cutting_force', 'calc_tool_life', 'calc_mrr', 'calc_surface_finish',\n    'calc_power', 'calc_deflection', 'calc_stability', 'calc_thermal',\n    'calc_speed_feed', 'calc_chip_load', 'calc_engagement', 'calc_trochoidal',\n    'calc_hsm', 'calc_scallop', 'calc_stepover', 'calc_cycle_time',\n    'calc_arc_fit', 'calc_cost_optimize', 'calc_multi_optimize', 'calc_productivity',\n    'prism_cutting_force', 'prism_tool_life', 'prism_speed_feed', 'prism_formula_calc',\n  ],\n  \n  // Tools that trigger factual verification\n  webTools: ['web_search', 'web_fetch'],\n  \n  // Claim indicators for Φ(x) verification\n  claimIndicators: [\n    'studies show', 'research indicates', 'according to', 'data shows',\n    'evidence suggests', 'proven that', 'the fact that', 'it is known that',\n    'established that', 'scientists found', 'experts agree',\n  ],\n  \n  // Safety thresholds\n  thresholds: {\n    lambda_min: 0.90,\n    phi_high: 0.85,\n    phi_moderate: 0.60,\n    safety_min: 0.70,\n  },\n};\n\n\n// ============================================================================\n// HOOK EXECUTION HISTORY — HookExecution imported from prism-schema\n// ============================================================================\n\nconst hookHistory: HookExecution[] = [];\nconst MAX_HISTORY = 1000;\n\nfunction logHookExecution(execution: HookExecution): void {\n  hookHistory.unshift(execution);\n  if (hookHistory.length > MAX_HISTORY) {\n    hookHistory.pop();\n  }\n}\n\nexport function getHookHistory(limit: number = 50): HookExecution[] {\n  return hookHistory.slice(0, limit);\n}\n\n\n// ============================================================================\n// LAMBDA PROTOCOL - Λ(x) Formal Logic Proof Validation\n// ============================================================================\n\nfunction validateSafetyProof(context: ToolCallContext): ProofValidationResult {\n  const { tool_name, inputs, result } = context;\n  const issues: string[] = [];\n  let validityScore = 1.0;\n  \n  // Check input ranges\n  if (inputs) {\n    if (inputs.cutting_speed !== undefined) {\n      if (inputs.cutting_speed < 1 || inputs.cutting_speed > 2000) {\n        issues.push(`Cutting speed ${inputs.cutting_speed} outside valid range [1-2000] m/min`);\n        validityScore -= 0.3;\n      }\n    }\n    if (inputs.feed_per_tooth !== undefined) {"}